<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TacTicToe</title>
    {% load static %}
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/renderers/CSS3DRenderer.js"></script>
    <link rel="icon" href="{% static 'images/favicon.png' %}" type="image/png">
    <script src="{% static 'js/utils.js' %}"></script>
    <script src="{% static 'js/find_opponent.js' %}"></script>
    <script src="{% static 'js/game_over.js' %}"></script>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden;
        }
        .game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #d3d2c0;
        }

        .canvas-container {
            position: relative;
            width: min(90vh, 90vw);
            height: min(90vh, 90vw);
            max-width: 100%;
            max-height: 100vh;
        }

        @media (max-width: 768px) {
            .canvas-container {
                width: min(100vh, 100vw);
                height: min(100vh, 100vw);
                transform: translateY(-20%);
            }
        }

        canvas { 
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        #homeButton { position: absolute; left: 20px; top: 20px; padding: 10px 20px; font-size: 16px; }
        #toast-container {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
        }

        .toast {
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .toast.show {
            opacity: 1;
        }

        .rotation-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .rotation-button {
            position: absolute;
            padding: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            pointer-events: auto;
            display: none;
        }

        @media (min-width: 768px) {
            .rotation-button {
                display: block;
            }
        }

        .rotation-button svg {
            width: 40px;
            height: 40px;
            fill: #FFD700;
            transition: fill 0.2s;
        }

        .rotation-button:hover svg {
            fill: #DAA520;
        }

        .rotate-up {
            top: 35px; 
            left: 53%;
            transform: translateX(-50%);
        }

        .rotate-down {
            bottom: -10px;
            left: 53%;
            transform: translateX(-50%);
        }

        .rotate-left {
            left: 20px;
            top: 55%;
            transform: translateY(-50%);
        }

        .rotate-right {
            right: 0;
            top: 55%;
            transform: translateY(-50%);
        }

        .rotate-down svg {
            transform: rotate(180deg);
        }

        .rotate-left svg {
            transform: rotate(-90deg);
        }

        .rotate-right svg {
            transform: rotate(90deg);
        }

        /* Blocker styles */

        .blocker-widget {
            position: fixed;
            background-color: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            padding: 36px 16px;
            color: #fff;
            font-family: system-ui, -apple-system, sans-serif;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .blocker-widget {
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                width: auto;
            }
        }

        .blocker-widget-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 8px 0;
            white-space: nowrap;
            width: 100%;
        }

        .player-color-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .red { background-color: #ef4444; }
        .blue { background-color: #3b82f6; }

        .player-color-text {
            font-size: 18px;
            min-width: 60px;
        }

        .blocker-icons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .blocker-icon {
            width: 24px;
            height: 24px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .blocker-icon.filled {
            opacity: 1;
        }

        .blocker-select {
            text-align: center;
            cursor: pointer;
            width: fit-content; /* Limit width to content */
            margin: 0 auto; /* Keep it centered */
        }

        .blocker-background {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            transition: filter 0.2s ease;
            position: relative;
        }

        .blocker-widget-header {
            font-size: 22px;
            font-weight: 600;
            margin: 0 0 28px 0;
            text-align: center;
        }

        @media (min-width: 769px) {
            .blocker-widget {
                top: 50%;
                left: 60px;
                transform: translateY(-50%);
                width: 280px;
            }

            .blocker-background {
                margin: 20px auto 0;
            }
        }

        .blocker-background.selected {
            background-image: url("/static/images/blocker_background_selected.png");
        }

        .blocker-background:not(.selected) {
            background-image: url("/static/images/blocker_background.png");
        }

        @media (min-width: 769px) {
            .blocker-background:hover {
                filter: brightness(0.8);
            }
        }

        .blocker-piece {
            width: 60px;
            height: 60px;
            position: absolute;
            top: 10px;          
            left: 10px;         
            pointer-events: none;
        }

        .blocker-x-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 80px;
            height: 80px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .blocker-x-overlay.show {
            opacity: 1;
        }

        .blocker-x-overlay svg {
            width: 100%;
            height: 100%;
        }

        .blocker-x-overlay line {
            stroke: #ef4444;
            stroke-width: 6;
            stroke-linecap: round;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            .blocker-widget {
                padding: 20px 28px 20px;
            }
            
            .blocker-widget-header {
                font-size: 16px;
                margin: 0 0 8px 0;
            }

            .blocker-widget-content {
                flex-direction: row;
                align-items: center;
                gap: 16px;
            }

            .player-blocker-info {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .blocker-select {
                margin-top: 0;
            }

            .blocker-background {
                width: 60px;
                height: 60px;
            }

            .blocker-piece {
                width: 45px;
                height: 45px;
                top: 7.5px;
                left: 7.5px;
            }

            .blocker-x-overlay {
                width: 60px;
                height: 60px;
            }

            .player-row {
                margin: 4px 0;
            }

            .blocker-icons {
                margin-right: 16px;  /* Add some space between the icons and the blocker selector */
                margin-left: -16px;
            }
        }
    </style>
</head>
<body>
    <audio id="moveSound" src="{% static 'sounds/move.wav' %}" preload="auto"></audio>
    <!-- Click by complex_waveform -- https://freesound.org/s/213148/ -- License: Attribution 4.0 -->
    <audio id="winSound" src="{% static 'sounds/win.wav' %}" preload="auto"></audio>
    <!-- Good! by syseQ -- https://freesound.org/s/267528/ -- License: Creative Commons 0 -->
    <audio id="loseSound" src="{% static 'sounds/lose.wav' %}" preload="auto"></audio>
    <!-- negative_beeps.wav by themusicalnomad -- https://freesound.org/s/253886/ -- License: Creative Commons 0 -->
    <audio id="startSound" src="{% static 'sounds/start.wav' %}" preload="auto"></audio>
    <!-- Coin_C_09 by cabled_mess -- https://freesound.org/s/350876/ -- License: Creative Commons 0 -->
    <audio id="invalidSound" src="{% static 'sounds/invalid.wav' %}" preload="auto"></audio>
    <!-- GASP_UI_Reject.wav by Rob_Marion -- https://freesound.org/s/542040/ -- License: Creative Commons 0 -->
    <div id="toast-container">
        <div id="invalidMoveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            Invalid Move
        </div>
    </div>
    <div class="blocker-widget">
        <h3 class="blocker-widget-header">Blocker Pieces</h3>
        <div class="blocker-widget-content">
            <div class="player-blocker-info">
                <div class="player-row">
                    <div class="player-color-icon red"></div>
                    <span class="player-color-text">Red</span>
                    <div class="blocker-icons" id="red-blockers">
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                    </div>
                </div>
                <div class="player-row">
                    <div class="player-color-icon blue"></div>
                    <span class="player-color-text">Blue</span>
                    <div class="blocker-icons" id="blue-blockers">
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                        <svg class="blocker-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.783 2.826L12 1l8.217 1.826a1 1 0 0 1 .783.976v9.987a6 6 0 0 1-2.672 4.992L12 23l-6.328-4.219A6 6 0 0 1 3 13.79V3.802a1 1 0 0 1 .783-.976z"/>
                        </svg>
                    </div>
                </div>
            </div>
            <div id="blocker-select" class="blocker-select">
                <div class="blocker-background">
                    <img src="/static/images/red_blocker.png" class="blocker-piece" id="red-blocker">
                    <img src="/static/images/blue_blocker.png" class="blocker-piece" id="blue-blocker">
                    <div class="blocker-x-overlay" id="blockerXOverlay">
                        <svg viewBox="0 0 80 80">
                            <line x1="20" y1="20" x2="60" y2="60"/>
                            <line x1="60" y1="20" x2="20" y2="60"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="game-container">
        <div class="canvas-container">
            <canvas id="myCanvas"></canvas>
            <div class="rotation-controls">
                <button class="rotation-button rotate-up" aria-label="Rotate up" data-direction="up">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-down" aria-label="Rotate down" data-direction="down">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-left" aria-label="Rotate left" data-direction="left">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-right" aria-label="Rotate right" data-direction="right">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <script>
        let isRotating = false;
        let isJiggling = false;
        let ROTATION_DURATION = 600;
        let rotationLastFinished = Date.now();
        const ROTATION_BUFFER = 60;
        const isMobile = window.innerWidth <= 768;
        let playerColor = '{{ player_color }}';
        let gameOver = false;
        // ---------------------Scene setup----------------------------------------------------------
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
        let blockerWidget = null;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xd3d2c0);

        function onWindowResize() {
            adjustCameraPosition();
            adjustCameraForScreenSize();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        adjustCameraPosition();
        window.addEventListener('resize', onWindowResize, false);

        function adjustCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1) {
                camera.position.set(10, 6, 4);
            } else {
                camera.position.set(7, 4, 3);
            }
            camera.lookAt(scene.position);
        }

        document.querySelectorAll('.rotation-button').forEach(button => {
            button.addEventListener('click', (event) => {
                event.preventDefault();
                
                const direction = button.dataset.direction;
                let rotationDirection;

                switch (direction) {
                    case 'up':
                        rotationDirection = 'DOWN';
                        break;
                    case 'down':
                        rotationDirection = 'UP';
                        break;
                    case 'left':
                        rotationDirection = 'RIGHT';
                        break;
                    case 'right':
                        rotationDirection = 'LEFT';
                        break;
                    default:
                        return;
                }

                handleRotation(rotationDirection);
            });
        });

        function handleRotation(direction) {
            if (isRotating || (Date.now() - rotationLastFinished < ROTATION_BUFFER)) {
                return;
            }

            isRotating = true;

            const directionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            updateDirectionMapping(directionMapping, direction);
            localStorage.setItem('directionMapping', JSON.stringify(directionMapping));
            updatePieceLocations(direction);

            animateRotation(direction, () => {
                isRotating = false;
                rotationLastFinished = Date.now();
            });
        }

        let cameraDistance;
        const mobileFOV = 60;
        const desktopFOV = 75;

        function adjustCameraForScreenSize() {
            const aspect = window.innerWidth / window.innerHeight;

            if (isMobile) {
                camera.fov = mobileFOV;
                cameraDistance = 14;
                camera.position.set(0, 0, cameraDistance);
            } else {
                camera.fov = desktopFOV;
                cameraDistance = 10;
                camera.position.set(7, 4, 3);
            }

            camera.lookAt(scene.position);
            camera.updateProjectionMatrix();
        }
        adjustCameraForScreenSize();

        let touchStartX, touchStartY;
        let touchEndX, touchEndY;
        let isSwiping = false;
        const swipeThreshold = 80; // minimum distance for a swipe

        renderer.domElement.addEventListener('touchstart', onTouchStart, false);
        renderer.domElement.addEventListener('touchmove', onTouchMove, false);
        renderer.domElement.addEventListener('touchend', onTouchEnd, false);

        function onTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            isSwiping = false;
        }

        function onTouchMove(event) {
            event.preventDefault();
            
            touchEndX = event.touches[0].clientX;
            touchEndY = event.touches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                isSwiping = true;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            
            if (!isSwiping) {
                if (!gameOver) {
                    handleTap(event.changedTouches[0]);
                }
            } else {
                handleSwipe();
            }
            
            isSwiping = false;
        }

        function handleTap(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object);
                }
            }
        }

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    onKeyDown({ key: 'ArrowLeft' });
                } else {
                    onKeyDown({ key: 'ArrowRight' });
                }
            } else {
                if (deltaY > 0) {
                    onKeyDown({ key: 'ArrowUp' });
                } else {
                    onKeyDown({ key: 'ArrowDown' });
                }
            }
        }

        let neutralPiecesHidden = false;

        function toggleNeutralPiecesVisibility() {
            neutralPiecesHidden = !neutralPiecesHidden;
            applyNeutralPiecesVisibility();
        }

        function applyNeutralPiecesVisibility() {
            const opacity = neutralPiecesHidden ? 0.5 : 1.0;
            
            piecesGroup.children.forEach(sphere => {
                const pos = sphere.userData.originalPosition;
                const pieceType = gameState[pos.x][pos.y][pos.z];
                
                if (pieceType === 'BLACK' || pieceType === 'RED_BLOCKER' || pieceType === 'BLUE_BLOCKER') {
                    if (sphere.children.length > 0) {
                        const dotsSphere = sphere.children[0];
                        dotsSphere.children[0].material.opacity = opacity;
                        dotsSphere.children[0].material.transparent = opacity < 1.0;
                        for (let i = 1; i < dotsSphere.children.length; i++) {
                            dotsSphere.children[i].material.opacity = opacity;
                            dotsSphere.children[i].material.transparent = opacity < 1.0;
                        }
                    } else if (pieceType === 'BLACK') {
                        sphere.material.opacity = opacity;
                        sphere.material.transparent = opacity < 1.0;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }

        // Adding lights
        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        var pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-2, -2, -2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // Set Up Cube
        const cubeGroup = new THREE.Group();
        const boardGroup = new THREE.Group();
        const piecesGroup = new THREE.Group();
        cubeGroup.add(boardGroup);
        cubeGroup.add(piecesGroup);

        if (isMobile) {
            cubeGroup.position.set(-1.5, 0, 0);
        } else {
            cubeGroup.position.set(0, 0, 0);
        }

        function addTube(start, end) {
            var path = new THREE.LineCurve3(new THREE.Vector3(...start), new THREE.Vector3(...end));
            var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
            var mesh = new THREE.Mesh(geometry, tubeMaterial);
            boardGroup.add(mesh);
        }
        
        var tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xedd8a8});
        var edgePaths = [
            new THREE.Vector3(-3, -3, -3),
            new THREE.Vector3(3, -3, -3),
            new THREE.Vector3(3, 3, -3),
            new THREE.Vector3(-3, 3, -3),
            new THREE.Vector3(-3, -3, 3),
            new THREE.Vector3(3, -3, 3),
            new THREE.Vector3(3, 3, 3),
            new THREE.Vector3(-3, 3, 3),
        ];

        edgePaths.forEach((start, index) => {
            edgePaths.forEach((end, subIndex) => {
                if (start.distanceTo(end) === 6) {
                    addTube(start.toArray(), end.toArray());
                }
            });
        });

        var cubeSize = 6;
        var halfCubeSize = cubeSize / 2;
        var divisionSize = cubeSize / 3;
        for (let offset = -halfCubeSize; offset <= halfCubeSize; offset += divisionSize) {
            for (let z = -halfCubeSize; z <= halfCubeSize; z += divisionSize) {
                addTube([-halfCubeSize, offset, z], [halfCubeSize, offset, z]);
            }
            for (let y = -halfCubeSize; y <= halfCubeSize; y += divisionSize) {
                addTube([offset, y, -halfCubeSize], [offset, y, halfCubeSize]);
            }
            for (let x = -halfCubeSize; x <= halfCubeSize; x += divisionSize) {
                addTube([x, -halfCubeSize, offset], [x, halfCubeSize, offset]);
            }
        }

        // Set Up Balls
        var sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        var redMaterial = new THREE.MeshPhongMaterial({color: 0xdf7053});
        var blueMaterial = new THREE.MeshPhongMaterial({color: 0x5b95e1});
        var blackMaterial = new THREE.MeshPhongMaterial({color: 0x3b3934});
        var emptyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.0,
            depthWrite: false
        });
        var redHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0xdf7053,
            emissive: 0x333300
        })
        var blueHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0x5b95e1,
            emissive: 0x333300
        })
        let highlightMaterial = (playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;
        const redDotMaterial = new THREE.MeshPhongMaterial({ color: 0xdf7053 });
        const blueDotMaterial = new THREE.MeshPhongMaterial({ color: 0x5b95e1 });
        function createDotsSphere(color) {
            const sphere = new THREE.Group();
            const blackSphere = new THREE.Mesh(sphereGeometry, blackMaterial);
            sphere.add(blackSphere);

            const dotPositions = [
                [0, 1, 0], [0, -1, 0], [1, 0, 0], 
                [-1, 0, 0], [0, 0, 1], [0, 0, -1]
            ];

            dotPositions.forEach(pos => {
                const dotGeometry = new THREE.SphereGeometry(0.15, 32, 32);
                let dot;
                if (color == "blue") {
                    dot = new THREE.Mesh(dotGeometry, blueDotMaterial);
                }
                else {
                    dot = new THREE.Mesh(dotGeometry, redDotMaterial);
                }
                
                // Position the dot on the surface of the sphere
                const radius = 0.7;  // Matches the radius of the main sphere
                dot.position.set(pos[0] * radius, pos[1] * radius, pos[2] * radius);
                
                // Scale the dot to make it appear as a circle on the surface
                const scale = 1;
                dot.scale.set(scale, scale, 0.01);
                
                // Rotate the dot to align with the sphere's surface
                dot.lookAt(0, 0, 0);
                
                sphere.add(dot);
            });

            return sphere;
        }

        var clickableSpheres = [];
        var gameState = JSON.parse('{{ game_state|safe }}');
        gameState.forEach((layer, x) => {
            layer.forEach((row, y) => {
                row.forEach((cell, z) => {
                    var sphere;
                    switch (cell) {
                        case 'BLACK':
                            sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                            break;
                        case 'BLUE':
                            sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                            break;
                        case 'RED':
                            sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                            break;
                        default:
                            sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                    }
                    sphere.position.set(-y*2+2, -z*2+2, -x*2+2);
                    sphere.userData = {
                        position: {x: x, y: y, z: z},
                        originalPosition: {x: x, y: y, z: z},
                        clickable: (y == 0)
                    };
                    if (y == 0) {
                        clickableSpheres.push(sphere);
                    }
                    piecesGroup.add(sphere); 
                });
            });
        });

        scene.add(cubeGroup);

        function initGame() {
            blockerWidget = document.querySelector('.blocker-widget');

            // Add click handler for the blocker select
            const blockerSelect = document.querySelector('.blocker-select');
            const blockerBackground = blockerSelect.querySelector('.blocker-background');
            const xOverlay = document.getElementById('blockerXOverlay');

            blockerSelect.addEventListener('click', () => {
                if (!xOverlay.classList.contains('show')) {
                    isBlockerSelected = !isBlockerSelected;
                    if (isBlockerSelected) {
                        blockerBackground.classList.add('selected');
                    } else {
                        blockerBackground.classList.remove('selected');
                    }
                }
            });

            updateBlockerWidget(gameState);
        }

        // Initialize Raycaster
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        // Camera position
        camera.position.set(7, 4, 3);
        camera.lookAt(scene.position);

        function resizeRenderer() {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            return needResize;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            resizeRenderer();
            renderer.render(scene, camera);
        }

        animate();

        //--------------END-----Scene Setup-----END-----------------------------------------

        function playSound(soundType) {
            const sound = document.getElementById(soundType + "Sound");
            if (sound) {
                sound.play();
            }
        }

        function showToast(message) {
            const toast = document.getElementById('invalidMoveToast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const redWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0xe03c11,
            emissive: 0xe03c11,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });
        const blueWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0x116ae0,
            emissive: 0x116ae0,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });

        const highlightCubeGroup = new THREE.Group();
        cubeGroup.add(highlightCubeGroup);

        function highlightWinningRun(winner, winningRun) {
            if (!winningRun) return;
    
            if (isRotating) {
                setTimeout(() => highlightWinningRun(winner, winningRun), 40);
                return;
            }

            const winningMaterial = winner === 'RED' ? redWinningMaterial : blueWinningMaterial;

            winningRun.forEach(([x, y, z]) => {
                const cube = new THREE.Mesh(cubeGeometry, winningMaterial);
                const piece = piecesGroup.children.find(sphere => 
                    sphere.userData.originalPosition.x === x && 
                    sphere.userData.originalPosition.y === y && 
                    sphere.userData.originalPosition.z === z
                );
                if (piece) {
                    cube.position.copy(piece.position);
                    highlightCubeGroup.add(cube);
                }
            });

            renderer.render(scene, camera);
        }

        function jigglePieces(row, direction, callback) {
            if (isJiggling) return;
            isJiggling = true;

            const JIGGLE_DURATION = 450;
            const JIGGLE_AMPLITUDE = 0.15;

            const startPositions = row.map(piece => piece.position.clone());
            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / JIGGLE_DURATION, 1);

                if (progress < 1) {
                    const displacement = Math.sin(progress * Math.PI * 7) * JIGGLE_AMPLITUDE * (1 - progress);

                    row.forEach((piece, index) => {
                        const start = startPositions[index];
                        switch (direction) {
                            case 'LEFT':
                            case 'RIGHT':
                                piece.position.set(
                                    start.x,
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                            case 'FRONT':
                            case 'BACK':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y,
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                            case 'UP':
                            case 'DOWN':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z
                                );
                        }
                    });

                    requestAnimationFrame(update);
                } else {
                    row.forEach((piece, index) => {
                        piece.position.copy(startPositions[index]);
                    });

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function getRowToJiggle(piece) {
            const { x, y, z } = piece.userData.position;
            const row = [];
            
            piecesGroup.children.forEach(sphere => {
                if (sphere.userData.position.x === x && sphere.userData.position.z === z) {
                    row.push(sphere);
                }
            });
            
            return row;
        }

        var lastIntersected = null;

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);

            if (intersects.length > 0) {
                if (lastIntersected !== intersects[0].object) {
                    if (lastIntersected) {
                        lastIntersected.material = lastIntersected.currentMaterial;
                    }
                    lastIntersected = intersects[0].object;
                    lastIntersected.currentMaterial = lastIntersected.material;
                    lastIntersected.material = highlightMaterial;
                }
            } else {
                if (lastIntersected) {
                    lastIntersected.material = lastIntersected.currentMaterial;
                    lastIntersected = null;
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove, false);

        function onMouseOut(event) {
            if (lastIntersected) {
                lastIntersected.material = lastIntersected.currentMaterial;
                lastIntersected = null;
            }
        }

        window.addEventListener('mouseout', onMouseOut, false);

        function onKeyDown(event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    direction = 'DOWN';
                    break;
                case 'ArrowDown':
                case 's':
                    direction = 'UP';
                    break;
                case 'ArrowLeft':
                case 'a':
                    direction = 'RIGHT';
                    break;
                case 'ArrowRight':
                case 'd':
                    direction = 'LEFT';
                    break;
                case 'v':
                    toggleNeutralPiecesVisibility();
                    return;
                default:
                    return;
            }
            handleRotation(direction);
        }

        window.addEventListener('keydown', onKeyDown, false);

        let isBlockerSelected = false;

        function onMouseClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object);
                }
            }
        }

        window.addEventListener('click', onMouseClick, false);

        function rotateCube(direction) {
            // Update pieces game board indexed locations in cube
            updatePieceLocations(direction);
            // Update pieces actual locations in space for rendering
            rotatePieces(direction);
        }

        function reapplyRotations() {
            // Starting at the default mapping, rotate until we get to the current mapping (cube rotation). This will rotate the game 
            // state to match the rotation the user currently has set
            const targetDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            let directionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'};
            let count = 0;
            while (!(directionMapping['TOP'] == targetDirectionMapping['TOP'])) {
                if (count % 2 == 0) {
                    if (count % 4 == 0) {
                        rotateCube('LEFT');
                        updateDirectionMapping(directionMapping, 'LEFT');
                    }
                    else {
                        rotateCube('RIGHT');
                        updateDirectionMapping(directionMapping, 'RIGHT');
                    }
                }
                else {
                    rotateCube('UP');
                    updateDirectionMapping(directionMapping, 'UP');
                }
                count += 1;
            }
            while (!(directionMapping['FRONT'] == targetDirectionMapping['FRONT'])) {
                rotateCube('RIGHT');
                updateDirectionMapping(directionMapping, 'RIGHT');
            }
        }

        function updateDirectionMapping(directionMapping, direction) {
            // Update the mapping in place depending on rotation
            frontVal = directionMapping['FRONT']
            switch (direction) {
                case 'UP':
                    directionMapping['FRONT'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['TOP'];
                    directionMapping['TOP'] = frontVal;
                    break;
                case 'DOWN':
                    directionMapping['FRONT'] = directionMapping['TOP'];
                    directionMapping['TOP'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = frontVal;
                    break;
                case 'LEFT':
                    directionMapping['FRONT'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = frontVal;
                    break;
                case 'RIGHT':
                    directionMapping['FRONT'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = frontVal;
                    break;
            }
        }

        function updateClickableSpheres() {
            clickableSpheres = [];
            piecesGroup.children.forEach(sphere => {
                if (sphere.userData.position.y === 0) {
                    sphere.userData.clickable = true;
                    clickableSpheres.push(sphere);
                }
                else {
                    sphere.userData.clickable = false;
                }
            });
        }

        function updatePieceLocations(direction) {
            piecesGroup.children.forEach(sphere => {
                var x = sphere.userData.position.x;
                var y = sphere.userData.position.y;
                var z = sphere.userData.position.z;
                switch (direction) {
                    case 'UP':
                        sphere.userData.position = { x: x, y: -z + 2, z: y };
                        break;
                    case 'DOWN':
                        sphere.userData.position = { x: x, y: z, z: -y + 2 };
                        break;
                    case 'LEFT':
                        sphere.userData.position = { x: y, y: -x + 2, z: z };
                        break;
                    case 'RIGHT':
                        sphere.userData.position = { x: -y + 2, y: x, z: z };
                        break;
                }
            });
            updateClickableSpheres();
        }

        function rotatePieces(direction) {
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            var rotation = new THREE.Matrix4().makeRotationAxis(axis.normalize(), angle);
            piecesGroup.children.forEach(sphere => {
                sphere.position.applyMatrix4(rotation);
            });

            renderer.render(scene, camera);
        }

        let totalRotation = new THREE.Quaternion();

        function animateRotation(direction, callback) {
            const startQuaternion = new THREE.Quaternion().copy(cubeGroup.quaternion);
            const endQuaternion = new THREE.Quaternion();
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            endQuaternion.setFromAxisAngle(axis.normalize(), angle);
            endQuaternion.multiply(startQuaternion);

            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / ROTATION_DURATION, 1);

                if (progress < 1) {
                    THREE.Quaternion.slerp(startQuaternion, endQuaternion, cubeGroup.quaternion, progress);
                    requestAnimationFrame(update);
                } else {
                    cubeGroup.quaternion.copy(endQuaternion);
                    totalRotation.multiply(endQuaternion);

                    if (lastIntersected) {
                        const fakeEvent = new MouseEvent('mousemove', {
                            clientX: (mouse.x + 1) * window.innerWidth / 2,
                            clientY: (-mouse.y + 1) * window.innerHeight / 2
                        });
                        onMouseMove(fakeEvent);
                    }

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function updateBlockerWidget(gameState) {
            if (!blockerWidget) return;

            let redCount = 0;
            let blueCount = 0;
            let moveCount = 0;

            gameState.forEach(layer => {
                layer.forEach(row => {
                    row.forEach(cell => {
                        if (cell === 'RED_BLOCKER') redCount++;
                        if (cell === 'BLUE_BLOCKER') blueCount++;
                        if (cell === 'RED' || cell === 'BLUE') moveCount++;
                    });
                });
            });

            const redIcons = document.querySelectorAll('#red-blockers .blocker-icon');
            redIcons.forEach((icon, index) => {
                if (index < redCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            const blueIcons = document.querySelectorAll('#blue-blockers .blocker-icon');
            blueIcons.forEach((icon, index) => {
                if (index < blueCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            // Show the correct blocker piece based on player color
            const redBlocker = document.getElementById('red-blocker');
            const blueBlocker = document.getElementById('blue-blocker');
            const xOverlay = document.getElementById('blockerXOverlay');
            
            redBlocker.style.display = playerColor === 'RED' ? 'block' : 'none';
            blueBlocker.style.display = playerColor === 'BLUE' ? 'block' : 'none';

            if (playerColor === 'RED' && moveCount === 0) {
                xOverlay.classList.add('show');
            } else {
                xOverlay.classList.remove('show');
            }
        }

        function updateGameState(newGameState) {
            if (isRotating) {
                return new Promise(resolve => {
                    const checkRotation = () => {
                        if (!isRotating) {
                            performUpdate();
                            resolve();
                        } else {
                            requestAnimationFrame(checkRotation);
                        }
                    };
                    checkRotation();
                });
            } else {
                performUpdate();
                return Promise.resolve();
            }

            function performUpdate() {
                gameState = JSON.parse(JSON.stringify(newGameState));

                while (piecesGroup.children.length > 0) {
                    piecesGroup.remove(piecesGroup.children[0]);
                }
                
                cubeGroup.quaternion.set(0, 0, 0, 1);

                gameState.forEach((layer, x) => {
                    layer.forEach((row, y) => {
                        row.forEach((cell, z) => {
                            let sphere;
                            switch (cell) {
                                case "BLACK":
                                    sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                                    break;
                                case "BLUE":
                                    sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                                    break;
                                case "RED":
                                    sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                                    break;
                                case "BLUE_BLOCKER":
                                    sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                    const blueDotsSphere = createDotsSphere('blue');
                                    sphere.add(blueDotsSphere);
                                    break;
                                case "RED_BLOCKER":
                                    sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                    const redDotsSphere = createDotsSphere('red');
                                    sphere.add(redDotsSphere);
                                    break;
                                default:
                                    sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                            }
                            sphere.position.set(-y * 2 + 2, -z * 2 + 2, -x * 2 + 2);
                            sphere.userData = {
                                position: { x: x, y: y, z: z },
                                originalPosition: { x: x, y: y, z: z },
                                clickable: (y === 0)
                            };

                            piecesGroup.add(sphere);
                        });
                    });
                });

                if (blockerWidget) {
                    updateBlockerWidget(gameState);
                }

                highlightMaterial = (playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;

                reapplyRotations();
                updateClickableSpheres();
                renderer.render(scene, camera);
            }
        }

        function sideToDirection(side) {
            switch(side) {
                case 'TOP':
                    return 'UP'
                case 'BOTTOM':
                    return 'DOWN'
                default:
                    return side
            }
        }

        // ON SCREEN CONSOLE
        // let onScreenConsole;
        // function initOnScreenConsole() {
        //     onScreenConsole = document.createElement('div');
        //     onScreenConsole.style.position = 'fixed';
        //     onScreenConsole.style.bottom = '0';
        //     onScreenConsole.style.left = '0';
        //     onScreenConsole.style.right = '0';
        //     onScreenConsole.style.backgroundColor = 'rgba(0,0,0,0.7)';
        //     onScreenConsole.style.color = 'white';
        //     onScreenConsole.style.padding = '10px';
        //     onScreenConsole.style.fontFamily = 'monospace';
        //     onScreenConsole.style.fontSize = '12px';
        //     onScreenConsole.style.maxHeight = '30%';
        //     onScreenConsole.style.overflowY = 'auto';
        //     onScreenConsole.style.zIndex = '9999';
        //     document.body.appendChild(onScreenConsole);

        //     onScreenConsole.innerHTML = 'On-screen console initialized.<br>';
        // }
        // console.log = function() {
        //     const msg = Array.from(arguments).join(' ');
        //     if (onScreenConsole) {
        //         onScreenConsole.innerHTML += msg + '<br>';
        //         onScreenConsole.scrollTop = onScreenConsole.scrollHeight;
        //     }
        // }
        // initOnScreenConsole();

        initGame();
    </script>
    {% block scripts %}{% endblock %}
</body>
</html>
