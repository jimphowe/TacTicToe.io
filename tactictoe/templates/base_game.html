<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TacTicToe</title>
    {% load static %}
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/renderers/CSS3DRenderer.js"></script>
    <link rel="icon" href="{% static 'images/favicon.svg' %}" type="image/png">
    <script src="{% static 'js/utils.js' %}"></script>
    <script src="{% static 'js/find_opponent.js' %}"></script>
    <script src="{% static 'js/game_over.js' %}"></script>
    <script src="{% static 'js/icons.js' %}"></script>
    <script src="{% static 'js/components/SettingsPanel.js' %}"></script>
    <script src="{% static 'js/components/GameControls.js' %}"></script>
    <script src="{% static 'js/components/PlayerGuide.js' %}"></script>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden;
        }
        .game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--game-background-color, #d3d2c0);
        }

        .canvas-container {
            position: relative;
            width: min(90vh, 90vw);
            height: min(90vh, 90vw);
            max-width: 100%;
            max-height: 100vh;
        }

        @media (max-width: 768px) {
            .canvas-container {
                width: min(100vh, 100vw);
                height: min(100vh, 100vw);
                transform: translateY(-20%);
            }
        }

        canvas { 
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        #homeButton { position: absolute; left: 20px; top: 20px; padding: 10px 20px; font-size: 16px; }
        #toast-container {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
        }

        .toast {
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .toast.show {
            opacity: 1;
        }

        .rotation-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .rotation-button {
            position: absolute;
            padding: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            pointer-events: auto;
            display: none;
        }

        @media (min-width: 768px) {
            .rotation-button {
                display: block;
            }
        }

        .rotation-button svg {
            width: 40px;
            height: 40px;
            fill: #FFD700;
            transition: fill 0.2s;
        }

        .rotation-button:hover svg {
            fill: #DAA520;
        }

        .rotate-up {
            top: 35px; 
            left: 53%;
            transform: translateX(-50%);
        }

        .rotate-down {
            bottom: -10px;
            left: 53%;
            transform: translateX(-50%);
        }

        .rotate-left {
            left: 20px;
            top: 55%;
            transform: translateY(-50%);
        }

        .rotate-right {
            right: 0;
            top: 55%;
            transform: translateY(-50%);
        }

        .rotate-down svg {
            transform: rotate(180deg);
        }

        .rotate-left svg {
            transform: rotate(-90deg);
        }

        .rotate-right svg {
            transform: rotate(90deg);
        }
    </style>
</head>
<body>
    <audio id="moveSound" src="{% static 'sounds/move.wav' %}" preload="auto"></audio>
    <!-- Click by complex_waveform -- https://freesound.org/s/213148/ -- License: Attribution 4.0 -->
    <audio id="winSound" src="{% static 'sounds/win.wav' %}" preload="auto"></audio>
    <!-- Good! by syseQ -- https://freesound.org/s/267528/ -- License: Creative Commons 0 -->
    <audio id="loseSound" src="{% static 'sounds/lose.wav' %}" preload="auto"></audio>
    <!-- negative_beeps.wav by themusicalnomad -- https://freesound.org/s/253886/ -- License: Creative Commons 0 -->
    <audio id="startSound" src="{% static 'sounds/start.wav' %}" preload="auto"></audio>
    <!-- Coin_C_09 by cabled_mess -- https://freesound.org/s/350876/ -- License: Creative Commons 0 -->
    <audio id="invalidSound" src="{% static 'sounds/invalid.wav' %}" preload="auto"></audio>
    <!-- GASP_UI_Reject.wav by Rob_Marion -- https://freesound.org/s/542040/ -- License: Creative Commons 0 -->
    <div id="toast-container">
        <div id="invalidMoveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            Invalid Move
        </div>
    </div>
    <div id="settings-panel-root"></div>
    <div id="game-controls-root"></div>
    <div class="game-container">
        <div class="canvas-container">
            <canvas id="myCanvas"></canvas>
            <div class="rotation-controls">
                <button class="rotation-button rotate-up" aria-label="Rotate up" data-direction="up">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-down" aria-label="Rotate down" data-direction="down">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-left" aria-label="Rotate left" data-direction="left">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-right" aria-label="Rotate right" data-direction="right">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <script>
        let isRotating = false;
        let isJiggling = false;
        let ROTATION_DURATION = 600;
        let rotationLastFinished = Date.now();
        const ROTATION_BUFFER = 60;
        let isAnimating = false;
        const ANIMATION_DURATION = 1000;
        const isMobile = window.innerWidth <= 768;
        let gameOver = false;
        let highlightMaterial;
        const DRAG_SENSITIVITY = 0.004;   // rad / px
        const SNAP_DURATION    = 400;     // ms

        let isPointerDragging  = false;
        let draggedThisGesture = false;
        let suppressNextClick  = false;
        let lastPointerXY      = {x:0, y:0};
        // ---------------------Scene setup----------------------------------------------------------
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
        let blockerWidget = null;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xd3d2c0);

        function onWindowResize() {
            adjustCameraForScreenSize();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

        document.addEventListener('DOMContentLoaded', (event) => {
            window.playerColor = '{{ player_color }}';
            window.redPower = '{{ red_power }}';
            window.bluePower = '{{ blue_power }}';
            window.myId = '{{ request.user.id }}';
            window.isBlockerSelected = false;

            const settingsRoot = document.getElementById('settings-panel-root');
            if (settingsRoot) {
                ReactDOM.render(React.createElement(window.SettingsPanel), settingsRoot);
            }

            const gameControlsRoot = document.getElementById('game-controls-root');
            if (gameControlsRoot) {
                ReactDOM.render(React.createElement(window.GameControls), gameControlsRoot);
            }

            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseout', onMouseOut, false);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            highlightMaterial = (window.playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;

            const defaultDirectionMapping = { 
                'FRONT': 'FRONT', 
                'BACK': 'BACK', 
                'LEFT': 'LEFT', 
                'RIGHT': 'RIGHT', 
                'TOP': 'TOP', 
                'BOTTOM': 'BOTTOM'
            };
            localStorage.setItem('directionMapping', JSON.stringify(defaultDirectionMapping));
            if (isMobile) updateMobilePanels();
        });

        document.querySelectorAll('.rotation-button').forEach(button => {
            button.addEventListener('click', (event) => {
                event.preventDefault();
                
                const direction = button.dataset.direction;
                let rotationDirection;

                switch (direction) {
                    case 'up':
                        rotationDirection = 'DOWN';
                        break;
                    case 'down':
                        rotationDirection = 'UP';
                        break;
                    case 'left':
                        rotationDirection = 'RIGHT';
                        break;
                    case 'right':
                        rotationDirection = 'LEFT';
                        break;
                    default:
                        return;
                }

                handleRotation(rotationDirection);
            });
        });

        function handleRotation(direction) {
            if (isRotating || (Date.now() - rotationLastFinished < ROTATION_BUFFER)) {
                return;
            }

            isRotating = true;

            animateRotation(direction, () => {
                applyQuarterTurn(direction);   // updates mapping, piece positions, clickables, mobile panels

                baseQuaternion.copy(cubeGroup.quaternion);      // keeps next drag smooth
                isRotating = false;
                rotationLastFinished = Date.now();
            });
        }

        let cameraDistance;
        const mobileFOV = 60;
        const desktopFOV = 75;

        function adjustCameraForScreenSize() {
            const aspect = window.innerWidth / window.innerHeight;

            if (isMobile) {
                camera.fov = mobileFOV;
                cameraDistance = 14;
                camera.position.set(10, 6, 4);
            } else {
                camera.fov = desktopFOV;
                cameraDistance = 10;
                camera.position.set(7, 4, 3);
            }

            camera.lookAt(scene.position);
            camera.updateProjectionMatrix();
        }
        adjustCameraForScreenSize();

        let touchStartX, touchStartY;
        let touchEndX, touchEndY;
        let isSwiping = false;
        const swipeThreshold = 80; // minimum distance for a swipe

        function onTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            isSwiping = false;
        }

        function onTouchMove(event) {
            event.preventDefault();
            
            touchEndX = event.touches[0].clientX;
            touchEndY = event.touches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                isSwiping = true;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            
            if (!isSwiping) {
                if (!gameOver) {
                    handleTap(event.changedTouches[0]);
                }
            } else {
                handleSwipe();
            }
            
            isSwiping = false;
        }

        function handleTap(touch) {
            if (draggedThisGesture) suppressNextClick = true;
            const rect = renderer.domElement.getBoundingClientRect();
            const xNDC = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const yNDC = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

            // First try a panel (mobile only)
            let target;
            if (isMobile) {
                target = getObjectUnderTouch(xNDC, yNDC, mobilePanelGroup.children);
                if (target) {
                    const sphere = findPieceAtPosition(target.userData.board);
                    if (sphere?.userData?.clickable) {
                        handlePieceClick(sphere);
                        return;
                    }
                }
            }

            // Fallback (desktop or miss-tap)
            target = getObjectUnderTouch(xNDC, yNDC, clickableSpheres);
            if (target?.userData?.clickable) {
                handlePieceClick(target);
            }
        }

        function getObjectUnderTouch(xNDC, yNDC, objects) {
            raycaster.setFromCamera(new THREE.Vector2(xNDC, yNDC), camera);
            return raycaster.intersectObjects(objects, true)[0]?.object || null;
        }

        function handleSwipe() {
            // const deltaX = touchEndX - touchStartX;
            // const deltaY = touchEndY - touchStartY;
            
            // if (Math.abs(deltaX) > Math.abs(deltaY)) {
            //     if (deltaX > 0) {
            //         onKeyDown({ key: 'ArrowLeft' });
            //     } else {
            //         onKeyDown({ key: 'ArrowRight' });
            //     }
            // } else {
            //     if (deltaY > 0) {
            //         onKeyDown({ key: 'ArrowUp' });
            //     } else {
            //         onKeyDown({ key: 'ArrowDown' });
            //     }
            // }
        }

        let neutralPiecesHidden = false;

        function toggleNeutralPiecesVisibility() {
            neutralPiecesHidden = !neutralPiecesHidden;
            applyNeutralPiecesVisibility();
        }

        function applyNeutralPiecesVisibility() {
            const opacity = neutralPiecesHidden ? 0.5 : 1.0;
            
            piecesGroup.children.forEach(sphere => {
                const pos = sphere.userData.originalPosition;
                const pieceType = gameState[pos.x][pos.y][pos.z];
                
                if (pieceType === 'BLACK' || pieceType === 'RED_BLOCKER' || pieceType === 'BLUE_BLOCKER') {
                    if (sphere.children.length > 0) {
                        const dotsSphere = sphere.children[0];
                        dotsSphere.children[0].material.opacity = opacity;
                        dotsSphere.children[0].material.transparent = opacity < 1.0;
                        for (let i = 1; i < dotsSphere.children.length; i++) {
                            dotsSphere.children[i].material.opacity = opacity;
                            dotsSphere.children[i].material.transparent = opacity < 1.0;
                        }
                    } else if (pieceType === 'BLACK') {
                        sphere.material.opacity = opacity;
                        sphere.material.transparent = opacity < 1.0;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }

        // Adding lights
        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        var pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-2, -2, -2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // Set Up Cube
        const cubeGroup = new THREE.Group();
        const boardGroup = new THREE.Group();
        const piecesGroup = new THREE.Group();
        cubeGroup.add(boardGroup);
        cubeGroup.add(piecesGroup);

        if (isMobile) {
            cubeGroup.position.set(-1.5, 0, 0);
        } else {
            cubeGroup.position.set(0, 0, 0);
        }

        function addTube(start, end) {
            var path = new THREE.LineCurve3(new THREE.Vector3(...start), new THREE.Vector3(...end));
            var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
            var mesh = new THREE.Mesh(geometry, tubeMaterial);
            boardGroup.add(mesh);
        }
        
        {% if user.is_authenticated %}
            var backgroundColor = '{{ user.profile.background_color }}';
            var boardColor = '{{ user.profile.board_color }}';
        {% else %}
            var backgroundColor = '#d3d2c0';
            var boardColor = '#edd8a8';
        {% endif %}

        document.documentElement.style.setProperty('--game-background-color', backgroundColor);
        renderer.setClearColor(backgroundColor);
        tubeMaterial = new THREE.MeshPhongMaterial({ color: boardColor });

        // var tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xedd8a8});
        var edgePaths = [
            new THREE.Vector3(-3, -3, -3),
            new THREE.Vector3(3, -3, -3),
            new THREE.Vector3(3, 3, -3),
            new THREE.Vector3(-3, 3, -3),
            new THREE.Vector3(-3, -3, 3),
            new THREE.Vector3(3, -3, 3),
            new THREE.Vector3(3, 3, 3),
            new THREE.Vector3(-3, 3, 3),
        ];

        edgePaths.forEach((start, index) => {
            edgePaths.forEach((end, subIndex) => {
                if (start.distanceTo(end) === 6) {
                    addTube(start.toArray(), end.toArray());
                }
            });
        });

        var cubeSize = 6;
        var halfCubeSize = cubeSize / 2;
        var divisionSize = cubeSize / 3;
        for (let offset = -halfCubeSize; offset <= halfCubeSize; offset += divisionSize) {
            for (let z = -halfCubeSize; z <= halfCubeSize; z += divisionSize) {
                addTube([-halfCubeSize, offset, z], [halfCubeSize, offset, z]);
            }
            for (let y = -halfCubeSize; y <= halfCubeSize; y += divisionSize) {
                addTube([offset, y, -halfCubeSize], [offset, y, halfCubeSize]);
            }
            for (let x = -halfCubeSize; x <= halfCubeSize; x += divisionSize) {
                addTube([x, -halfCubeSize, offset], [x, halfCubeSize, offset]);
            }
        }

        let baseQuaternion     = new THREE.Quaternion().copy(cubeGroup.quaternion);
        let dragQuaternion     = new THREE.Quaternion();

        // Set Up Balls
        var sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        var redMaterial = new THREE.MeshPhongMaterial({color: 0xdf7053});
        var blueMaterial = new THREE.MeshPhongMaterial({color: 0x5b95e1});
        var blackMaterial = new THREE.MeshPhongMaterial({color: 0x3b3934});
        var emptyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.0,
            depthWrite: false
        });
        var redHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0xdf7053,
            emissive: 0x333300
        })
        var blueHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0x5b95e1,
            emissive: 0x333300
        })
        const redDotMaterial = new THREE.MeshPhongMaterial({ color: 0xdf7053 });
        const blueDotMaterial = new THREE.MeshPhongMaterial({ color: 0x5b95e1 });
        var mobilePanelMaterial = new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0.0,
            depthWrite: false
        });
        var panelGeometry = new THREE.PlaneGeometry(2, 2);

        const mobilePanelGroup = new THREE.Group();
        cubeGroup.add(mobilePanelGroup);

        /* =========  Mobile panels (tap targets)  ========= */

        const FACE_CFG = {
            FRONT : { fixed:{axis:'y',val:0},  normal:new THREE.Vector3( 1, 0, 0),
                        col:'x', colInv:false, row:'z', rowInv:false },

            BACK  : { fixed:{axis:'y',val:2},  normal:new THREE.Vector3(-1, 0, 0),
                        col:'x', colInv:true,  row:'z', rowInv:false },

            LEFT  : { fixed:{axis:'x',val:0},  normal:new THREE.Vector3( 0, 0, 1),
                        col:'y', colInv:true,  row:'z', rowInv:false },

            RIGHT : { fixed:{axis:'x',val:2},  normal:new THREE.Vector3( 0, 0,-1),
                        col:'y', colInv:false, row:'z', rowInv:false },

            TOP   : { fixed:{axis:'z',val:0},  normal:new THREE.Vector3( 0, 1, 0),
                        col:'x', colInv:false, row:'y', rowInv:true  },

            BOTTOM: { fixed:{axis:'z',val:2},  normal:new THREE.Vector3( 0,-1, 0),
                        col:'x', colInv:false, row:'y', rowInv:false }
        };

        function updateMobilePanels() {
            if (!isMobile) return;

            const faceKey = JSON.parse(localStorage.getItem('directionMapping')).FRONT;
            const cfg     = FACE_CFG[faceKey];

            mobilePanelGroup.clear();

            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {

                const board = {x:0, y:0, z:0};
                board[cfg.fixed.axis] = cfg.fixed.val;
                board[cfg.col] = cfg.colInv ? 2 - col : col;
                board[cfg.row] = cfg.rowInv ? 2 - row : row;

                const centre = gameToThreePosition(board.x, board.y, board.z);
                const pos = centre.clone().add(cfg.normal.clone().multiplyScalar(1.05));

                const panel = new THREE.Mesh(panelGeometry, mobilePanelMaterial);
                panel.position.copy(pos);

                panel.quaternion
                    .setFromUnitVectors(new THREE.Vector3(0,0,1), cfg.normal.clone());

                panel.userData = { board };
                mobilePanelGroup.add(panel);
                }
            }
        }

        function applyQuarterTurn(direction){
            console.log("TURNING")
            const map = JSON.parse(localStorage.getItem('directionMapping'));
            updateDirectionMapping(map, effectiveDir(direction));
            localStorage.setItem('directionMapping', JSON.stringify(map));
            updatePieceLocations(effectiveDir(direction));        // also refreshes clickables+panels
        }

        /* Update mapping + userData.position without touching meshes */
        function logicQuarterTurn(dir){
            const map = JSON.parse(localStorage.getItem('directionMapping'));
            updateDirectionMapping(map, effectiveDir(dir));
            localStorage.setItem('directionMapping', JSON.stringify(map));
            updatePieceLocations(effectiveDir(dir));          // rotates logical grid only
        }

        function snapToNearest90(){
            const currentQ   = cubeGroup.quaternion.clone();
            const currentE   = new THREE.Euler().setFromQuaternion(currentQ, 'YXZ');

            const snap = Math.PI / 2;

            const targetE = new THREE.Euler(
                Math.round(currentE.x / snap) * snap,
                Math.round(currentE.y / snap) * snap,
                Math.round(currentE.z / snap) * snap,
                'YXZ'
            );
            const targetQ = new THREE.Quaternion().setFromEuler(targetE);

            /* ------- 3a. smooth tween  ------- */
            const startQ   = currentQ.clone();
            const startT   = performance.now();

            (function animateSnap(now){
                const t = Math.min(1, (now - startT) / SNAP_DURATION);
                THREE.Quaternion.slerp(startQ, targetQ, cubeGroup.quaternion, t);
                if (t < 1){
                    requestAnimationFrame(animateSnap);
                    renderer.render(scene, camera);
                } else {
                    /* ------- 3b.   bring logic state in line (camera-aware) ------- */

                    // 1.  Figure out which original face vectors are now pointing
                    //     toward camera-forward, camera-right, camera-up, etc.
                    const CANON = {
                    FRONT : new THREE.Vector3( 1, 0, 0),
                    BACK  : new THREE.Vector3(-1, 0, 0),
                    LEFT  : new THREE.Vector3( 0, 0, 1),
                    RIGHT : new THREE.Vector3( 0, 0,-1),
                    TOP   : new THREE.Vector3( 0, 1, 0),
                    BOTTOM: new THREE.Vector3( 0,-1, 0),
                    };

                    // world vectors after snap
                    const worldVec = {};
                    for (const k in CANON){
                    worldVec[k] = CANON[k].clone().applyQuaternion(targetQ);
                    }

                    // camera basis
                    const camFwd   = new THREE.Vector3();
                    camera.getWorldDirection(camFwd).normalize();        // points FROM cube TO camera
                    const camToCube = camFwd.clone().multiplyScalar(-1); // opposite
                    const camRight = new THREE.Vector3()
                                        .crossVectors(new THREE.Vector3(0,1,0), camFwd)
                                        .normalize();
                    const camUp    = new THREE.Vector3()
                                        .crossVectors(camFwd, camRight)
                                        .normalize();

                    // helper to pick & remove the vector with largest dot to an axis
                    function takeMax(axis, pool){
                    let bestKey = null, bestDot = -Infinity;
                    for (const k of pool){
                        const d = worldVec[k].dot(axis);
                        if (d > bestDot){ bestDot = d; bestKey = k; }
                    }
                    pool.splice(pool.indexOf(bestKey),1);
                    return bestKey;
                    }

                    // 2.  Build a brand-new directionMapping from scratch
                    const pool = Object.keys(worldVec);
                    const newMap = {};                      // world-face ⇒ original‐face
                    newMap.FRONT   = takeMax(camToCube, pool);   // most facing camera
                    newMap.BACK    = takeMax(camFwd,    pool);
                    newMap.RIGHT   = takeMax(camRight,  pool);
                    newMap.LEFT    = takeMax(camRight.clone().negate(), pool);
                    newMap.TOP     = takeMax(camUp,     pool);
                    newMap.BOTTOM  = pool[0];                 // whatever is left

                    // 3.  Persist it and realign the *logical* board
                    localStorage.setItem('directionMapping', JSON.stringify(newMap));
                    /* rotate the logical board to match the new mapping, no visuals */
                    let cur = JSON.parse(localStorage.getItem('directionMapping'));
                    while (cur.TOP   !== newMap.TOP)   { logicQuarterTurn('UP');    cur = newMap; }
                    while (cur.FRONT !== newMap.FRONT) { logicQuarterTurn('RIGHT'); cur = newMap; }


                    // 4.  House-keeping for the next drag
                    baseQuaternion.copy(targetQ);
                    updateClickableSpheres();
                    updateMobilePanels();
                    isRotating = false;
                }
            })(startT);
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown, {passive:false});

        function clientXY(evt){
            if (evt.touches && evt.touches.length) {
                return {x: evt.touches[0].clientX, y: evt.touches[0].clientY};
            } else if (evt.changedTouches && evt.changedTouches.length){
                return {x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY};
            }
            return {x: evt.clientX, y: evt.clientY};
        }

        function onPointerDown(e){
            if (isRotating || isAnimating) return;      // already busy
            isPointerDragging = true;
            draggedThisGesture = false;
            isRotating        = true;                   // blocks moves / clicks
            lastPointerXY     = clientXY(e);
            dragQuaternion.identity();

            document.addEventListener('pointermove', onPointerMove, {passive:false});
            document.addEventListener('pointerup',   onPointerUp,   {passive:false});
        }

        function onPointerMove(e){
            if (!isPointerDragging) return;
            e.preventDefault();                          // stop page-scroll on mobile

            const {x, y}  = clientXY(e);
            const dx      = x - lastPointerXY.x;         // +dx  = drag-right
            const dy      = y - lastPointerXY.y;         // +dy  = drag-down
            lastPointerXY = {x, y};

            const movePx2 = dx*dx + dy*dy;
            if (movePx2 > 16) draggedThisGesture = true;

            // —— build camera-local axes ———————————————————————
            const forward = new THREE.Vector3();         // camera –Z
            camera.getWorldDirection(forward).normalize();

            const right   = new THREE.Vector3()
                            .crossVectors(new THREE.Vector3(0,1,0), forward)
                            .normalize();              // camera +X

            const up      = new THREE.Vector3()
                            .crossVectors(forward, right)
                            .normalize();              // camera +Y
            // ————————————————————————————————————————————————

            /*  Drag-right  ⇒ spin cube to the right   (intuitive)
                Drag-down   ⇒ pitch cube forward / toward you        */
            const qHoriz = new THREE.Quaternion()
                            .setFromAxisAngle(up,    dx * DRAG_SENSITIVITY);
            const qVert  = new THREE.Quaternion()
                            .setFromAxisAngle(right, -dy * DRAG_SENSITIVITY);

            dragQuaternion.premultiply(qHoriz).premultiply(qVert);
            cubeGroup.quaternion.copy(dragQuaternion).multiply(baseQuaternion);
        }

        function onPointerUp(){
            if (!isPointerDragging) return;
            isPointerDragging = false;

            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup',   onPointerUp);

            snapToNearest90();
            if (draggedThisGesture) suppressNextClick = true;
        }

        function createDotsSphere(color) {
            const sphere = new THREE.Group();
            const blackSphere = new THREE.Mesh(sphereGeometry, blackMaterial);
            sphere.add(blackSphere);

            const dotPositions = [
                [0, 1, 0], [0, -1, 0], [1, 0, 0], 
                [-1, 0, 0], [0, 0, 1], [0, 0, -1]
            ];

            dotPositions.forEach(pos => {
                const dotGeometry = new THREE.SphereGeometry(0.15, 32, 32);
                let dot;
                if (color == "blue") {
                    dot = new THREE.Mesh(dotGeometry, blueDotMaterial);
                }
                else {
                    dot = new THREE.Mesh(dotGeometry, redDotMaterial);
                }
                
                const radius = 0.7;
                dot.position.set(pos[0] * radius, pos[1] * radius, pos[2] * radius);
                
                const scale = 1;
                dot.scale.set(scale, scale, 0.01);
                
                dot.lookAt(0, 0, 0);
                
                sphere.add(dot);
            });

            return sphere;
        }

        var clickableSpheres = [];
        var gameState = JSON.parse('{{ game_state|safe }}');
        var currentGameState = gameState;
        gameState.forEach((layer, x) => {
            layer.forEach((row, y) => {
                row.forEach((cell, z) => {
                    var sphere;
                    switch (cell) {
                        case 'BLACK':
                            sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                            break;
                        case 'BLUE':
                            sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                            break;
                        case 'RED':
                            sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                            break;
                        default:
                            sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                    }
                    sphere.position.set(-y*2+2, -z*2+2, -x*2+2);
                    sphere.userData = {
                        position: {x: x, y: y, z: z},
                        originalPosition: {x: x, y: y, z: z},
                        clickable: (y == 0)
                    };
                    if (y == 0) {
                        clickableSpheres.push(sphere);
                    }
                    piecesGroup.add(sphere); 
                });
            });
        });

        scene.add(cubeGroup);

        // Initialize Raycaster
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        // Camera position
        camera.position.set(7, 4, 3);
        camera.lookAt(scene.position);

        function resizeRenderer() {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            return needResize;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            resizeRenderer();
            renderer.render(scene, camera);
        }

        animate();

        //--------------END-----Scene Setup-----END-----------------------------------------

        window.soundsMuted = false;

        window.toggleSoundsMuted = function(muted) {
            window.soundsMuted = muted;
        };

        function playSound(soundType) {
            if (window.soundsMuted) return;
            const sound = document.getElementById(soundType + "Sound");
            if (sound) {
                sound.play();
            }
        }

        function showToast(message) {
            const toast = document.getElementById('invalidMoveToast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const redWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0xe03c11,
            emissive: 0xe03c11,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });
        const blueWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0x116ae0,
            emissive: 0x116ae0,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });

        const highlightCubeGroup = new THREE.Group();
        cubeGroup.add(highlightCubeGroup);

        function highlightWinningRun(winner, winningRun) {
            if (!winningRun) return;
    
            if (isRotating) {
                setTimeout(() => highlightWinningRun(winner, winningRun), 40);
                return;
            }

            const winningMaterial = winner === 'RED' ? redWinningMaterial : blueWinningMaterial;

            winningRun.forEach(([x, y, z]) => {
                const cube = new THREE.Mesh(cubeGeometry, winningMaterial);
                const piece = piecesGroup.children.find(sphere => 
                    sphere.userData.originalPosition.x === x && 
                    sphere.userData.originalPosition.y === y && 
                    sphere.userData.originalPosition.z === z
                );
                if (piece) {
                    cube.position.copy(piece.position);
                    highlightCubeGroup.add(cube);
                }
            });

            renderer.render(scene, camera);
        }

        function jigglePieces(row, direction, callback) {
            if (isJiggling) return;
            isJiggling = true;

            const JIGGLE_DURATION = 450;
            const JIGGLE_AMPLITUDE = 0.15;

            const startPositions = row.map(piece => piece.position.clone());
            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / JIGGLE_DURATION, 1);

                if (progress < 1) {
                    const displacement = Math.sin(progress * Math.PI * 7) * JIGGLE_AMPLITUDE * (1 - progress);

                    row.forEach((piece, index) => {
                        const start = startPositions[index];
                        switch (direction) {
                            case 'LEFT':
                            case 'RIGHT':
                                piece.position.set(
                                    start.x,
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                                break;
                            case 'FRONT':
                            case 'BACK':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y,
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                                break;
                            case 'UP':
                            case 'DOWN':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z
                                );
                                break;
                        }
                    });

                    requestAnimationFrame(update);
                } else {
                    row.forEach((piece, index) => {
                        piece.position.copy(startPositions[index]);
                    });

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function getRowToJiggle(piece) {
            const { x, y, z } = piece.userData.originalPosition;
            const currentDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            const backDirection = currentDirectionMapping['BACK'];
            const row = [];
            
            piecesGroup.children.forEach(sphere => {
                const spherePos = sphere.userData.originalPosition;
                switch(backDirection) {
                    case 'FRONT':
                    case 'BACK':
                        if (spherePos.x === x && spherePos.z === z) {
                            row.push(sphere);
                        }
                        break;
                    case 'LEFT':
                    case 'RIGHT':
                        if (spherePos.y === y && spherePos.z === z) {
                            row.push(sphere);
                        }
                        break;
                    case 'TOP':
                    case 'BOTTOM':
                        if (spherePos.x === x && spherePos.y === y) {
                            row.push(sphere);
                        }
                        break;
                }
            });
            
            let sortedRow = [...row];
            let coordKey;
            let ascending;
            
            switch(backDirection) {
                case 'FRONT':
                    coordKey = 'y';
                    ascending = false;
                    break;
                case 'BACK':
                    coordKey = 'y';
                    ascending = true;
                    break;
                case 'LEFT':
                    coordKey = 'x';
                    ascending = false;
                    break;
                case 'RIGHT':
                    coordKey = 'x';
                    ascending = true;
                    break;
                case 'TOP':
                    coordKey = 'z';
                    ascending = false;
                    break;
                case 'BOTTOM':
                    coordKey = 'z';
                    ascending = true;
                    break;
            }
            
            sortedRow.sort((a, b) => {
                if (ascending) {
                    return a.userData.originalPosition[coordKey] - b.userData.originalPosition[coordKey];
                } else {
                    return b.userData.originalPosition[coordKey] - a.userData.originalPosition[coordKey];
                }
            });
            
            if (sortedRow.length === 3) {
                const middlePiece = sortedRow[1];
                const middlePieceType = getPieceType(middlePiece);
                
                if (middlePieceType === 'EMPTY') {
                    return sortedRow.slice(0, 2);
                }
            }
            
            return row;
        }

        function needsYawFlip() {
            return true
            // Rounded quarter-turn counts around X and Z
            const xQ = Math.round(cubeGroup.rotation.x / (Math.PI / 2)) & 1;
            const zQ = Math.round(cubeGroup.rotation.z / (Math.PI / 2)) & 1;
            return xQ ^ zQ;          // XOR → true when the cube lies on its side
        }

        function effectiveDir(dir) {
            return (needsYawFlip() && (dir === "LEFT" || dir === "RIGHT"))
                    ? (dir === "LEFT" ? "RIGHT" : "LEFT")
                    : dir;
        }


        var lastIntersected = null;

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);

            if (intersects.length > 0) {
                if (lastIntersected !== intersects[0].object) {
                    if (lastIntersected) {
                        lastIntersected.material = lastIntersected.currentMaterial;
                    }
                    lastIntersected = intersects[0].object;
                    lastIntersected.currentMaterial = lastIntersected.material;
                    lastIntersected.material = highlightMaterial;
                }
            } else {
                if (lastIntersected) {
                    lastIntersected.material = lastIntersected.currentMaterial;
                    lastIntersected = null;
                }
            }
        }

        function onMouseOut(event) {
            if (lastIntersected) {
                lastIntersected.material = lastIntersected.currentMaterial;
                lastIntersected = null;
            }
        }

        function onKeyDown(event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    direction = 'DOWN';
                    break;
                case 'ArrowDown':
                case 's':
                    direction = 'UP';
                    break;
                case 'ArrowLeft':
                case 'a':
                    direction = 'RIGHT';
                    break;
                case 'ArrowRight':
                case 'd':
                    direction = 'LEFT';
                    break;
                case 'v':
                    toggleNeutralPiecesVisibility();
                    return;
                default:
                    return;
            }
            handleRotation(direction);
        }

        window.addEventListener('keydown', onKeyDown, false);

        function onMouseClick(event) {
            if (suppressNextClick) { suppressNextClick = false; return; }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object);
                }
            }
        }

        function rotateCube(direction) {
            // Update pieces game board indexed locations in cube
            updatePieceLocations(direction);
            // Update pieces actual locations in space for rendering
            rotatePieces(direction);
        }

        function reapplyRotations() {
            // Starting at the default mapping, rotate until we get to the current mapping (cube rotation). This will rotate the game 
            // state to match the rotation the user currently has set
            const targetDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            let directionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'};
            let count = 0;
            while (!(directionMapping['TOP'] == targetDirectionMapping['TOP'])) {
                if (count % 2 == 0) {
                    if (count % 4 == 0) {
                        rotateCube('LEFT');
                        updateDirectionMapping(directionMapping, 'LEFT');
                    }
                    else {
                        rotateCube('RIGHT');
                        updateDirectionMapping(directionMapping, 'RIGHT');
                    }
                }
                else {
                    rotateCube('UP');
                    updateDirectionMapping(directionMapping, 'UP');
                }
                count += 1;
            }
            while (!(directionMapping['FRONT'] == targetDirectionMapping['FRONT'])) {
                rotateCube('RIGHT');
                updateDirectionMapping(directionMapping, 'RIGHT');
            }
        }

        function updateDirectionMapping(directionMapping, direction) {
            // Update the mapping in place depending on rotation
            frontVal = directionMapping['FRONT']
            switch (direction) {
                case 'UP':
                    directionMapping['FRONT'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['TOP'];
                    directionMapping['TOP'] = frontVal;
                    break;
                case 'DOWN':
                    directionMapping['FRONT'] = directionMapping['TOP'];
                    directionMapping['TOP'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = frontVal;
                    break;
                case 'LEFT':
                    directionMapping['FRONT'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = frontVal;
                    break;
                case 'RIGHT':
                    directionMapping['FRONT'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = frontVal;
                    break;
            }
        }

        function updateClickableSpheres() {
            clickableSpheres = [];
            const currentMapping = JSON.parse(localStorage.getItem('directionMapping'));
            let clickableCoord, clickableValue;

            // Determine which board coordinate should be considered "front"
            switch (currentMapping.FRONT) {
                case 'FRONT':
                    clickableCoord = 'y';
                    clickableValue = 0;
                    break;
                case 'BACK':
                    clickableCoord = 'y';
                    clickableValue = 2;
                    break;
                case 'LEFT':
                    clickableCoord = 'x';
                    clickableValue = 0;
                    break;
                case 'RIGHT':
                    clickableCoord = 'x';
                    clickableValue = 2;
                    break;
                case 'TOP':
                    clickableCoord = 'z';
                    clickableValue = 0;
                    break;
                case 'BOTTOM':
                    clickableCoord = 'z';
                    clickableValue = 2;
                    break;
                default:
                    clickableCoord = 'y';
                    clickableValue = 0;
            }

            updateMobilePanels();

            // Use originalPosition (which is never modified by rotations)
            piecesGroup.children.forEach(sphere => {
                if (sphere.userData.originalPosition[clickableCoord] === clickableValue) {
                    sphere.userData.clickable = true;
                    clickableSpheres.push(sphere);
                } else {
                    sphere.userData.clickable = false;
                }
            });
        }

        function updatePieceLocations(direction) {
            piecesGroup.children.forEach(sphere => {
                var x = sphere.userData.position.x;
                var y = sphere.userData.position.y;
                var z = sphere.userData.position.z;
                switch (direction) {
                    case 'UP':
                        sphere.userData.position = { x: x, y: -z + 2, z: y };
                        break;
                    case 'DOWN':
                        sphere.userData.position = { x: x, y: z, z: -y + 2 };
                        break;
                    case 'LEFT':
                        sphere.userData.position = { x: y, y: -x + 2, z: z };
                        break;
                    case 'RIGHT':
                        sphere.userData.position = { x: -y + 2, y: x, z: z };
                        break;
                }
            });
            updateClickableSpheres();
        }

        function rotatePieces(direction) {
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            var rotation = new THREE.Matrix4().makeRotationAxis(axis.normalize(), angle);
            piecesGroup.children.forEach(sphere => {
                sphere.position.applyMatrix4(rotation);
            });

            renderer.render(scene, camera);
        }

        let totalRotation = new THREE.Quaternion();

        function animateRotation(direction, callback) {
            const startQuaternion = new THREE.Quaternion().copy(cubeGroup.quaternion);
            const endQuaternion = new THREE.Quaternion();
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            endQuaternion.setFromAxisAngle(axis.normalize(), angle);
            endQuaternion.multiply(startQuaternion);

            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / ROTATION_DURATION, 1);

                if (progress < 1) {
                    THREE.Quaternion.slerp(startQuaternion, endQuaternion, cubeGroup.quaternion, progress);
                    requestAnimationFrame(update);
                } else {
                    cubeGroup.quaternion.copy(endQuaternion);
                    totalRotation.multiply(endQuaternion);

                    if (lastIntersected) {
                        const fakeEvent = new MouseEvent('mousemove', {
                            clientX: (mouse.x + 1) * window.innerWidth / 2,
                            clientY: (-mouse.y + 1) * window.innerHeight / 2
                        });
                        onMouseMove(fakeEvent);
                    }

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function updateBlockerWidget(gameState) {
            if (!blockerWidget) return;

            let redCount = 0;
            let blueCount = 0;
            let moveCount = 0;

            gameState.forEach(layer => {
                layer.forEach(row => {
                    row.forEach(cell => {
                        if (cell === 'RED_BLOCKER') redCount++;
                        if (cell === 'BLUE_BLOCKER') blueCount++;
                        if (cell === 'RED' || cell === 'BLUE') moveCount++;
                    });
                });
            });

            const redIcons = document.querySelectorAll('#red-blockers .blocker-icon');
            redIcons.forEach((icon, index) => {
                if (index < redCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            const blueIcons = document.querySelectorAll('#blue-blockers .blocker-icon');
            blueIcons.forEach((icon, index) => {
                if (index < blueCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            // Show the correct blocker piece based on player color
            const redBlocker = document.getElementById('red-blocker');
            const blueBlocker = document.getElementById('blue-blocker');
            const xOverlay = document.getElementById('blockerXOverlay');
            
            redBlocker.style.display = window.playerColor === 'RED' ? 'block' : 'none';
            blueBlocker.style.display = window.playerColor === 'BLUE' ? 'block' : 'none';

            if (window.playerColor === 'RED' && moveCount === 0) {
                xOverlay.classList.add('show');
            } else {
                xOverlay.classList.remove('show');
            }
        }

        function animatePush(piece, startPos, endPos) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const duration = 500;

                function update() {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    
                    // Cubic easing
                    const easedProgress = progress < 0.5 
                        ? 4 * progress * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    piece.position.lerpVectors(startPos, endPos, easedProgress);

                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        piece.position.copy(endPos);
                        resolve();
                    }

                    renderer.render(scene, camera);
                }

                update();
            });
        }

        function getPieceType(piece) {
            if (piece.material === redMaterial) return 'RED';
            if (piece.material === blueMaterial) return 'BLUE';
            if (piece.material === blackMaterial) return 'BLACK';
            if (piece.children.length > 0) {
                return piece.children[0].children[1].material === redDotMaterial ? 'RED_BLOCKER' : 'BLUE_BLOCKER';
            }
            return 'EMPTY';
        }

        function gameToThreePosition(x, y, z) {
            return new THREE.Vector3(-y * 2 + 2, -z * 2 + 2, -x * 2 + 2);
        }

        function findPieceAtPosition(pos) {
            return piecesGroup.children.find(sphere => 
                sphere.userData.originalPosition.x === pos.x && 
                sphere.userData.originalPosition.y === pos.y && 
                sphere.userData.originalPosition.z === pos.z
            );
        }

        function getRotatedDirection(direction) {
            const directionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            // Find which face is currently facing which direction
            for (const [currentFace, originalFace] of Object.entries(directionMapping)) {
                if (originalFace === direction) {
                    return currentFace;
                }
            }
            return direction;
        }

        function calculatePushEndPosition(piece, direction) {
            const pos = piece.position.clone();
            const PUSH_DISTANCE = 2;

            // Create base push vector (before any rotations)
            let pushVector = new THREE.Vector3();
            
            // In the base orientation:
            // BACK means -x in Three.js space
            // LEFT means +z in Three.js space
            // UP means +y in Three.js space
            switch(direction) {
                case 'BACK':
                    pushVector.set(-PUSH_DISTANCE, 0, 0);
                    break;
                case 'FRONT':
                    pushVector.set(PUSH_DISTANCE, 0, 0);
                    break;
                case 'LEFT':
                    pushVector.set(0, 0, PUSH_DISTANCE);
                    break;
                case 'RIGHT':
                    pushVector.set(0, 0, -PUSH_DISTANCE);
                    break;
                case 'UP':
                    pushVector.set(0, PUSH_DISTANCE, 0);
                    break;
                case 'DOWN':
                    pushVector.set(0, -PUSH_DISTANCE, 0);
                    break;
            }
            
            pos.add(pushVector);
            
            return pos;
        }

        function getPiecesToPush(origin, direction, count) {
            const pieces = [];
            const firstPiece = findPieceAtPosition(origin);
            if (!firstPiece || count === 0) return pieces;
            
            pieces.push(firstPiece);
            let currentPos = {...origin};

            for (let i = 1; i < count; i++) {
                switch (direction) {
                    case 'BACK': currentPos.y++; break;
                    case 'FRONT': currentPos.y--; break;
                    case 'LEFT': currentPos.x--; break;
                    case 'RIGHT': currentPos.x++; break;
                    case 'UP': currentPos.z--; break;
                    case 'DOWN': currentPos.z++; break;
                }
                
                const nextPiece = findPieceAtPosition(currentPos);
                if (nextPiece) {
                    pieces.push(nextPiece);
                }
            }
            
            return pieces;
        }

        function updateGameState(newGameState, pushInfo = null) {
            return new Promise(resolve => {
                if (isAnimating || isRotating) {
                    requestAnimationFrame(() => {
                        updateGameState(newGameState, pushInfo).then(resolve);
                    });
                    return;
                }
                // Save the current local rotation (client’s view)
                const currentRotation = cubeGroup.quaternion.clone();
                
                if (pushInfo && pushInfo.pieces_pushed > 0) {
                    const { origin, direction, pieces_pushed } = pushInfo;
                    const piecesToMove = getPiecesToPush(origin, direction, pieces_pushed);
                    
                    if (piecesToMove.length > 0) {
                        isAnimating = true;
                        const animations = piecesToMove.map(piece => {
                            const startPos = piece.position.clone();
                            const endPos = calculatePushEndPosition(piece, direction);
                            return animatePush(piece, startPos, endPos);
                        });
                        
                        Promise.all(animations).then(() => {
                            isAnimating = false;
                            // Rebuild board from canonical state...
                            updatePiecesFromGameState(newGameState);
                            // ...then restore the saved rotation.
                            cubeGroup.quaternion.copy(currentRotation);
                            updateClickableSpheres();
                            resolve();
                        });
                    } else {
                        updatePiecesFromGameState(newGameState);
                        cubeGroup.quaternion.copy(currentRotation);
                        updateClickableSpheres();
                        resolve();
                    }
                } else {
                    // Even for non-push moves, rebuild and then restore the local rotation.
                    updatePiecesFromGameState(newGameState);
                    cubeGroup.quaternion.copy(currentRotation);
                    updateClickableSpheres();
                    resolve();
                }
            });
        }

        function updatePiecesFromGameState(newGameState) {
            // Update both currentGameState and gameState
            currentGameState = JSON.parse(JSON.stringify(newGameState));
            gameState = newGameState;  // Keep gameState synced for backward compatibility
            
            // Clear existing pieces
            while (piecesGroup.children.length > 0) {
                piecesGroup.remove(piecesGroup.children[0]);
            }

            // Create new pieces in final positions
            gameState.forEach((layer, x) => {
                layer.forEach((row, y) => {
                    row.forEach((cell, z) => {
                        let sphere;
                        switch (cell) {
                            case "BLACK":
                                sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                                break;
                            case "BLUE":
                                sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                                break;
                            case "RED":
                                sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                                break;
                            case "BLUE_BLOCKER":
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                const blueDotsSphere = createDotsSphere('blue');
                                sphere.add(blueDotsSphere);
                                break;
                            case "RED_BLOCKER":
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                const redDotsSphere = createDotsSphere('red');
                                sphere.add(redDotsSphere);
                                break;
                            default:
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                        }
                        const threePos = gameToThreePosition(x, y, z);
                        sphere.position.copy(threePos);
                        sphere.userData = {
                            position: { x: x, y: y, z: z },
                            originalPosition: { x: x, y: y, z: z },
                            clickable: (y === 0)
                        };
                        piecesGroup.add(sphere);
                    });
                });
            });

            if (blockerWidget) {
                updateBlockerWidget(gameState);
            }

            highlightMaterial = (playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;
            piecesGroup.children.forEach(sphere => {
                sphere.userData.position = sphere.position.clone();
            });
            updateClickableSpheres();
            renderer.render(scene, camera);
        }

        function sideToDirection(side) {
            switch(side) {
                case 'TOP':
                    return 'UP'
                case 'BOTTOM':
                    return 'DOWN'
                default:
                    return side
            }
        }

        // ON SCREEN CONSOLE
        let onScreenConsole;
        function initOnScreenConsole() {
            onScreenConsole = document.createElement('div');
            onScreenConsole.style.position = 'fixed';
            onScreenConsole.style.bottom = '0';
            onScreenConsole.style.left = '0';
            onScreenConsole.style.right = '0';
            onScreenConsole.style.backgroundColor = 'rgba(0,0,0,0.7)';
            onScreenConsole.style.color = 'white';
            onScreenConsole.style.padding = '10px';
            onScreenConsole.style.fontFamily = 'monospace';
            onScreenConsole.style.fontSize = '12px';
            onScreenConsole.style.maxHeight = '30%';
            onScreenConsole.style.overflowY = 'auto';
            onScreenConsole.style.zIndex = '9999';
            document.body.appendChild(onScreenConsole);

            onScreenConsole.innerHTML = 'On-screen console initialized.<br>';
        }
        console.log = function() {
            const msg = Array.from(arguments).join(' ');
            if (onScreenConsole) {
                onScreenConsole.innerHTML += msg + '<br>';
                onScreenConsole.scrollTop = onScreenConsole.scrollHeight;
            }
        }
        // initOnScreenConsole();
    </script>
    {% block scripts %}{% endblock %}
</body>
</html>

