<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TacTicToe</title>
    {% load static %}
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/renderers/CSS3DRenderer.js"></script>
    <link rel="icon" href="{% static 'images/favicon.svg' %}" type="image/png">
    <script src="{% static 'js/utils.js' %}"></script>
    <script src="{% static 'js/find_opponent.js' %}"></script>
    <script src="{% static 'js/game_over.js' %}"></script>
    <script src="{% static 'js/icons.js' %}"></script>
    <script src="{% static 'js/components/SettingsPanel.js' %}"></script>
    <script src="{% static 'js/components/GameControls.js' %}"></script>
    <script src="{% static 'js/components/PlayerGuide.js' %}"></script>
    <link rel="stylesheet" href="{% static 'css/base_game.css' %}">
    <link rel="stylesheet" href="{% static 'css/settings_panel.css' %}">
    <link rel="stylesheet" href="{% static 'css/player_guide.css' %}">
    <link rel="stylesheet" href="{% static 'css/game_controls.css' %}">
</head>
<body>
    <audio id="moveSound" src="{% static 'sounds/move.wav' %}" preload="auto"></audio>
    <!-- Click by complex_waveform -- https://freesound.org/s/213148/ -- License: Attribution 4.0 -->
    <audio id="winSound" src="{% static 'sounds/win.wav' %}" preload="auto"></audio>
    <!-- Good! by syseQ -- https://freesound.org/s/267528/ -- License: Creative Commons 0 -->
    <audio id="loseSound" src="{% static 'sounds/lose.wav' %}" preload="auto"></audio>
    <!-- negative_beeps.wav by themusicalnomad -- https://freesound.org/s/253886/ -- License: Creative Commons 0 -->
    <audio id="startSound" src="{% static 'sounds/start.wav' %}" preload="auto"></audio>
    <!-- Coin_C_09 by cabled_mess -- https://freesound.org/s/350876/ -- License: Creative Commons 0 -->
    <audio id="invalidSound" src="{% static 'sounds/invalid.wav' %}" preload="auto"></audio>
    <!-- GASP_UI_Reject.wav by Rob_Marion -- https://freesound.org/s/542040/ -- License: Creative Commons 0 -->
    <div id="toast-container">
        <div id="invalidMoveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            Invalid Move
        </div>
    </div>
    <div id="settings-panel-root"></div>
    <div id="game-controls-root"></div>
    <div class="game-container">
        <div class="canvas-container">
            <canvas id="myCanvas"></canvas>
            <div class="rotation-controls">
                <button class="rotation-button rotate-up" aria-label="Rotate up" data-direction="up">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-down" aria-label="Rotate down" data-direction="down">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-left" aria-label="Rotate left" data-direction="left">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
                
                <button class="rotation-button rotate-right" aria-label="Rotate right" data-direction="right">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2 L3 14 L21 14 Z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <script>
        let isRotating = false;
        let isJiggling = false;
        let ROTATION_DURATION = 600;
        let rotationLastFinished = Date.now();
        const ROTATION_BUFFER = 60;
        let isAnimating = false;
        const ANIMATION_DURATION = 1000;
        const isMobile = window.innerWidth <= 768;
        let gameOver = false;
        let highlightMaterial;
        const SNAP_DURATION    = 400;     // ms

        // Board size configuration - passed from Django template
        const BOARD_SIZE = {{ board_size|default:3 }};
        const MAX_COORD = BOARD_SIZE - 1;

        let isPointerDragging  = false;
        let draggedThisGesture = false;
        let suppressNextClick  = false;
        let lastPointerXY      = {x:0, y:0};
        // ---------------------Scene setup----------------------------------------------------------
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
        let blockerWidget = null;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xd3d2c0);

        function onWindowResize() {
            adjustCameraForScreenSize();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

        document.addEventListener('DOMContentLoaded', (event) => {
            window.playerColor = '{{ player_color }}';
            window.redPower = '{{ red_power }}';
            window.bluePower = '{{ blue_power }}';
            window.myId = '{{ request.user.id }}';
            window.isBlockerSelected = false;

            const settingsRoot = document.getElementById('settings-panel-root');
            if (settingsRoot) {
                ReactDOM.render(React.createElement(window.SettingsPanel), settingsRoot);
            }

            const gameControlsRoot = document.getElementById('game-controls-root');
            if (gameControlsRoot) {
                ReactDOM.render(React.createElement(window.GameControls), gameControlsRoot);
            }

            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseout', onMouseOut, false);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            highlightMaterial = (window.playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;

            const defaultDirectionMapping = { 
                'FRONT': 'FRONT', 
                'BACK': 'BACK', 
                'LEFT': 'LEFT', 
                'RIGHT': 'RIGHT', 
                'TOP': 'TOP', 
                'BOTTOM': 'BOTTOM'
            };
            localStorage.setItem('directionMapping', JSON.stringify(defaultDirectionMapping));
            if (isMobile) updateMobilePanels();
        });

        document.querySelectorAll('.rotation-button').forEach(button => {
            button.addEventListener('click', (event) => {
                event.preventDefault();
                
                const direction = button.dataset.direction;
                let rotationDirection;

                switch (direction) {
                    case 'up':
                        rotationDirection = 'DOWN';
                        break;
                    case 'down':
                        rotationDirection = 'UP';
                        break;
                    case 'left':
                        rotationDirection = 'RIGHT';
                        break;
                    case 'right':
                        rotationDirection = 'LEFT';
                        break;
                    default:
                        return;
                }

                handleRotation(rotationDirection);
            });
        });

        function handleRotation(direction) {
            if (isRotating || (Date.now() - rotationLastFinished < ROTATION_BUFFER)) {
                return;
            }

            isRotating = true;

            animateRotation(direction, () => {
                applyQuarterTurn(direction);   // updates mapping, piece positions, clickables, mobile panels

                baseQuaternion.copy(cubeGroup.quaternion);      // keeps next drag smooth
                isRotating = false;
                rotationLastFinished = Date.now();
            });
        }

        let cameraDistance;
        const mobileFOV = 60;
        const desktopFOV = 75;

        function adjustCameraForScreenSize() {
            const aspect = window.innerWidth / window.innerHeight;
            // Increase camera distance for 4x4x4 boards
            const boardSizeMultiplier = BOARD_SIZE === 4 ? 1.35 : 1.0;

            if (isMobile) {
                camera.fov = mobileFOV;
                cameraDistance = 14 * boardSizeMultiplier;
                camera.position.set(10 * boardSizeMultiplier, 6 * boardSizeMultiplier, 4 * boardSizeMultiplier);
            } else {
                camera.fov = desktopFOV;
                cameraDistance = 10 * boardSizeMultiplier;
                camera.position.set(7 * boardSizeMultiplier, 4 * boardSizeMultiplier, 3 * boardSizeMultiplier);
            }

            camera.lookAt(scene.position);
            camera.updateProjectionMatrix();
        }
        adjustCameraForScreenSize();

        let touchStartX, touchStartY;
        let touchEndX, touchEndY;
        let isSwiping = false;
        const swipeThreshold = 80; // minimum distance for a swipe

        function onTouchStart(event) {
            event.preventDefault();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            isSwiping = false;
        }

        function onTouchMove(event) {
            event.preventDefault();
            
            touchEndX = event.touches[0].clientX;
            touchEndY = event.touches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                isSwiping = true;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            
            if (!isSwiping) {
                if (!gameOver) {
                    handleTap(event.changedTouches[0]);
                }
            } else {
                handleSwipe();
            }
            
            isSwiping = false;
        }

        function handleTap(touch) {
            if (draggedThisGesture) suppressNextClick = true;
            const rect = renderer.domElement.getBoundingClientRect();
            const xNDC = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const yNDC = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

            // First try a panel (mobile only)
            let target;
            if (isMobile) {
                target = getObjectUnderTouch(xNDC, yNDC, mobilePanelGroup.children);
                if (target) {
                    const sphere = findPieceAtPosition(target.userData.board);
                    if (sphere?.userData?.clickable) {
                        handlePieceClick(sphere);
                        return;
                    }
                }
            }

            // Fallback (desktop or miss-tap)
            target = getObjectUnderTouch(xNDC, yNDC, clickableSpheres);
            if (target?.userData?.clickable) {
                handlePieceClick(target);
            }
        }

        function getObjectUnderTouch(xNDC, yNDC, objects) {
            raycaster.setFromCamera(new THREE.Vector2(xNDC, yNDC), camera);
            return raycaster.intersectObjects(objects, true)[0]?.object || null;
        }

        function handleSwipe() {
            // const deltaX = touchEndX - touchStartX;
            // const deltaY = touchEndY - touchStartY;
            
            // if (Math.abs(deltaX) > Math.abs(deltaY)) {
            //     if (deltaX > 0) {
            //         onKeyDown({ key: 'ArrowLeft' });
            //     } else {
            //         onKeyDown({ key: 'ArrowRight' });
            //     }
            // } else {
            //     if (deltaY > 0) {
            //         onKeyDown({ key: 'ArrowUp' });
            //     } else {
            //         onKeyDown({ key: 'ArrowDown' });
            //     }
            // }
        }

        let neutralPiecesHidden = false;

        function toggleNeutralPiecesVisibility() {
            neutralPiecesHidden = !neutralPiecesHidden;
            applyNeutralPiecesVisibility();
        }

        function applyNeutralPiecesVisibility() {
            const opacity = neutralPiecesHidden ? 0.5 : 1.0;
            
            piecesGroup.children.forEach(sphere => {
                const pos = sphere.userData.originalPosition;
                const pieceType = gameState[pos.x][pos.y][pos.z];
                
                if (pieceType === 'BLACK' || pieceType === 'RED_BLOCKER' || pieceType === 'BLUE_BLOCKER') {
                    if (sphere.children.length > 0) {
                        const dotsSphere = sphere.children[0];
                        dotsSphere.children[0].material.opacity = opacity;
                        dotsSphere.children[0].material.transparent = opacity < 1.0;
                        for (let i = 1; i < dotsSphere.children.length; i++) {
                            dotsSphere.children[i].material.opacity = opacity;
                            dotsSphere.children[i].material.transparent = opacity < 1.0;
                        }
                    } else if (pieceType === 'BLACK') {
                        sphere.material.opacity = opacity;
                        sphere.material.transparent = opacity < 1.0;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }

        // Adding lights
        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        var pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-2, -2, -2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // Set Up Cube
        const cubeGroup = new THREE.Group();
        const boardGroup = new THREE.Group();
        const piecesGroup = new THREE.Group();
        cubeGroup.add(boardGroup);
        cubeGroup.add(piecesGroup);

        if (isMobile) {
            cubeGroup.position.set(-1.5, 0, 0);
        } else {
            cubeGroup.position.set(0, 0, 0);
        }

        function addTube(start, end) {
            var path = new THREE.LineCurve3(new THREE.Vector3(...start), new THREE.Vector3(...end));
            var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
            var mesh = new THREE.Mesh(geometry, tubeMaterial);
            boardGroup.add(mesh);
        }
        
        {% if user.is_authenticated %}
            var backgroundColor = '{{ user.profile.background_color }}';
            var boardColor = '{{ user.profile.board_color }}';
        {% else %}
            var backgroundColor = '#d3d2c0';
            var boardColor = '#edd8a8';
        {% endif %}

        document.documentElement.style.setProperty('--game-background-color', backgroundColor);
        renderer.setClearColor(backgroundColor);
        tubeMaterial = new THREE.MeshPhongMaterial({ color: boardColor });

        // var tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xedd8a8});
        // Calculate cube dimensions based on board size
        var cubeSize = BOARD_SIZE * 2;  // 6 for 3x3x3, 8 for 4x4x4
        var halfCubeSize = cubeSize / 2;

        var edgePaths = [
            new THREE.Vector3(-halfCubeSize, -halfCubeSize, -halfCubeSize),
            new THREE.Vector3(halfCubeSize, -halfCubeSize, -halfCubeSize),
            new THREE.Vector3(halfCubeSize, halfCubeSize, -halfCubeSize),
            new THREE.Vector3(-halfCubeSize, halfCubeSize, -halfCubeSize),
            new THREE.Vector3(-halfCubeSize, -halfCubeSize, halfCubeSize),
            new THREE.Vector3(halfCubeSize, -halfCubeSize, halfCubeSize),
            new THREE.Vector3(halfCubeSize, halfCubeSize, halfCubeSize),
            new THREE.Vector3(-halfCubeSize, halfCubeSize, halfCubeSize),
        ];

        edgePaths.forEach((start, index) => {
            edgePaths.forEach((end, subIndex) => {
                if (start.distanceTo(end) === cubeSize) {
                    addTube(start.toArray(), end.toArray());
                }
            });
        });

        var divisionSize = cubeSize / BOARD_SIZE;
        for (let offset = -halfCubeSize; offset <= halfCubeSize; offset += divisionSize) {
            for (let z = -halfCubeSize; z <= halfCubeSize; z += divisionSize) {
                addTube([-halfCubeSize, offset, z], [halfCubeSize, offset, z]);
            }
            for (let y = -halfCubeSize; y <= halfCubeSize; y += divisionSize) {
                addTube([offset, y, -halfCubeSize], [offset, y, halfCubeSize]);
            }
            for (let x = -halfCubeSize; x <= halfCubeSize; x += divisionSize) {
                addTube([x, -halfCubeSize, offset], [x, halfCubeSize, offset]);
            }
        }

        let baseQuaternion     = new THREE.Quaternion().copy(cubeGroup.quaternion);
        let dragQuaternion     = new THREE.Quaternion();

        var sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        var redMaterial = new THREE.MeshPhongMaterial({color: 0xdf7053});
        var blueMaterial = new THREE.MeshPhongMaterial({color: 0x5b95e1});
        var blackMaterial = new THREE.MeshPhongMaterial({color: 0x3b3934});
        var emptyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.0,
            depthWrite: false
        });
        var redHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0xdf7053,
            emissive: 0x333300
        })
        var blueHighlightMaterial = new THREE.MeshPhongMaterial({
            color: 0x5b95e1,
            emissive: 0x333300
        })
        const redDotMaterial = new THREE.MeshPhongMaterial({ color: 0xdf7053 });
        const blueDotMaterial = new THREE.MeshPhongMaterial({ color: 0x5b95e1 });
        var mobilePanelMaterial = new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0.0,
            depthWrite: false
        });
        var panelGeometry = new THREE.PlaneGeometry(2, 2);

        const mobilePanelGroup = new THREE.Group();
        cubeGroup.add(mobilePanelGroup);

        /* =========  Mobile panels (tap targets)  ========= */

        const FACE_CFG = {
            FRONT : { fixed:{axis:'y',val:0},  normal:new THREE.Vector3( 1, 0, 0),
                        col:'x', colInv:false, row:'z', rowInv:false },

            BACK  : { fixed:{axis:'y',val:MAX_COORD},  normal:new THREE.Vector3(-1, 0, 0),
                        col:'x', colInv:true,  row:'z', rowInv:false },

            LEFT  : { fixed:{axis:'x',val:0},  normal:new THREE.Vector3( 0, 0, 1),
                        col:'y', colInv:true,  row:'z', rowInv:false },

            RIGHT : { fixed:{axis:'x',val:MAX_COORD},  normal:new THREE.Vector3( 0, 0,-1),
                        col:'y', colInv:false, row:'z', rowInv:false },

            TOP   : { fixed:{axis:'z',val:0},  normal:new THREE.Vector3( 0, 1, 0),
                        col:'x', colInv:false, row:'y', rowInv:true  },

            BOTTOM: { fixed:{axis:'z',val:MAX_COORD},  normal:new THREE.Vector3( 0,-1, 0),
                        col:'x', colInv:false, row:'y', rowInv:false }
        };

        function updateMobilePanels() {
            if (!isMobile) return;

            const faceKey = JSON.parse(localStorage.getItem('directionMapping')).FRONT;
            const cfg     = FACE_CFG[faceKey];

            mobilePanelGroup.clear();

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {

                const board = {x:0, y:0, z:0};
                board[cfg.fixed.axis] = cfg.fixed.val;
                board[cfg.col] = cfg.colInv ? MAX_COORD - col : col;
                board[cfg.row] = cfg.rowInv ? MAX_COORD - row : row;

                const centre = gameToThreePosition(board.x, board.y, board.z);
                const pos = centre.clone().add(cfg.normal.clone().multiplyScalar(1.05));

                const panel = new THREE.Mesh(panelGeometry, mobilePanelMaterial);
                panel.position.copy(pos);

                panel.quaternion
                    .setFromUnitVectors(new THREE.Vector3(0,0,1), cfg.normal.clone());

                panel.userData = { board };
                mobilePanelGroup.add(panel);
                }
            }
        }

        function applyQuarterTurn(direction){
            console.log("TURNING")
            const map = JSON.parse(localStorage.getItem('directionMapping'));
            updateDirectionMapping(map, logicalDir(direction));
            localStorage.setItem('directionMapping', JSON.stringify(map));
            updatePieceLocations(direction);
        }

        function logicQuarterTurn(dir){
            const map = JSON.parse(localStorage.getItem('directionMapping'));
            updateDirectionMapping(map, logicalDir(dir));
            localStorage.setItem('directionMapping', JSON.stringify(map));
            updatePieceLocations(dir);
        }

        function snapToNearest90(){
            const currentQ   = cubeGroup.quaternion.clone();
            const currentE   = new THREE.Euler().setFromQuaternion(currentQ, 'YXZ');

            const snap = Math.PI / 2;

            // Generate the few closest 90-degree orientations (not all possible ones)
            const baseX = Math.round(currentE.x / snap) * snap;
            const baseY = Math.round(currentE.y / snap) * snap;
            const baseZ = Math.round(currentE.z / snap) * snap;

            // Consider the nearest snap and its immediate neighbors
            const candidates = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const candidateE = new THREE.Euler(
                            baseX + dx * snap,
                            baseY + dy * snap, 
                            baseZ + dz * snap,
                            'YXZ'
                        );
                        const candidateQ = new THREE.Quaternion().setFromEuler(candidateE);
                        candidates.push({
                            quaternion: candidateQ,
                            euler: candidateE
                        });
                    }
                }
            }

            // Get camera direction
            const camFwd = new THREE.Vector3();
            camera.getWorldDirection(camFwd).normalize();
            const camToCube = camFwd.clone().multiplyScalar(-1);

            const FACE_NORMALS = {
                FRONT : new THREE.Vector3( 1, 0, 0),
                BACK  : new THREE.Vector3(-1, 0, 0),
                LEFT  : new THREE.Vector3( 0, 0, 1),
                RIGHT : new THREE.Vector3( 0, 0,-1),
                TOP   : new THREE.Vector3( 0, 1, 0),
                BOTTOM: new THREE.Vector3( 0,-1, 0),
            };

            // Score each candidate based on rotation distance + camera visibility
            let bestCandidate = null;
            let bestScore = -Infinity;

            for (const candidate of candidates) {
                // Calculate rotation distance (smaller is better)
                const rotationDistance = currentQ.angleTo(candidate.quaternion);
                
                // Calculate best face visibility for this orientation
                let maxVisibility = -Infinity;
                for (const normal of Object.values(FACE_NORMALS)) {
                    const worldNormal = normal.clone().applyQuaternion(candidate.quaternion);
                    const visibility = worldNormal.dot(camToCube);
                    maxVisibility = Math.max(maxVisibility, visibility);
                }

                // Combined score: prioritize good visibility, but don't ignore rotation distance
                const score = maxVisibility * 2 - rotationDistance;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestCandidate = candidate;
                }
            }

            const targetQ = bestCandidate ? bestCandidate.quaternion : new THREE.Quaternion().setFromEuler(new THREE.Euler(baseX, baseY, baseZ, 'YXZ'));

            const startQ   = currentQ.clone();
            const startT   = performance.now();

            (function animateSnap(now){
                const t = Math.min(1, (now - startT) / SNAP_DURATION);
                THREE.Quaternion.slerp(startQ, targetQ, cubeGroup.quaternion, t);
                if (t < 1){
                    requestAnimationFrame(animateSnap);
                    renderer.render(scene, camera);
                } else {
                    const CANON = {
                        FRONT : new THREE.Vector3( 1, 0, 0),
                        BACK  : new THREE.Vector3(-1, 0, 0),
                        LEFT  : new THREE.Vector3( 0, 0, 1),
                        RIGHT : new THREE.Vector3( 0, 0,-1),
                        TOP   : new THREE.Vector3( 0, 1, 0),
                        BOTTOM: new THREE.Vector3( 0,-1, 0),
                    };

                    // world vectors after snap
                    const worldVec = {};
                    for (const k in CANON){
                        worldVec[k] = CANON[k].clone().applyQuaternion(targetQ);
                    }

                    // camera basis
                    const camFwd   = new THREE.Vector3();
                    camera.getWorldDirection(camFwd).normalize();
                    const camToCube = camFwd.clone().multiplyScalar(-1);
                    const camRight = new THREE.Vector3()
                                        .crossVectors(new THREE.Vector3(0,1,0), camFwd)
                                        .normalize();
                    const camUp    = new THREE.Vector3()
                                        .crossVectors(camFwd, camRight)
                                        .normalize();

                    // helper to pick & remove the vector with largest dot to an axis
                    function takeMax(axis, pool){
                        let bestKey = null, bestDot = -Infinity;
                        for (const k of pool){
                            const d = worldVec[k].dot(axis);
                            if (d > bestDot){ bestDot = d; bestKey = k; }
                        }
                        pool.splice(pool.indexOf(bestKey),1);
                        return bestKey;
                    }

                    const pool = Object.keys(worldVec);
                    const newMap = {};
                    newMap.FRONT   = takeMax(camToCube, pool);
                    newMap.BACK    = takeMax(camFwd,    pool);
                    newMap.RIGHT   = takeMax(camRight,  pool);
                    newMap.LEFT    = takeMax(camRight.clone().negate(), pool);
                    newMap.TOP     = takeMax(camUp,     pool);
                    newMap.BOTTOM  = pool[0];

                    localStorage.setItem('directionMapping', JSON.stringify(newMap));

                    baseQuaternion.copy(targetQ);
                    updateClickableSpheres();
                    updateMobilePanels();
                    isRotating = false;
                }
            })(startT);
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown, {passive:false});

        function clientXY(evt){
            if (evt.touches && evt.touches.length) {
                return {x: evt.touches[0].clientX, y: evt.touches[0].clientY};
            } else if (evt.changedTouches && evt.changedTouches.length){
                return {x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY};
            }
            return {x: evt.clientX, y: evt.clientY};
        }

        function onPointerDown(e){
            if (isRotating || isAnimating) return;
            isPointerDragging = true;
            draggedThisGesture = false;
            isRotating        = true;
            lastPointerXY     = clientXY(e);
            dragQuaternion.identity();

            document.addEventListener('pointermove', onPointerMove, {passive:false});
            document.addEventListener('pointerup',   onPointerUp,   {passive:false});
        }

        function onPointerMove(e){
            if (!isPointerDragging) return;
            e.preventDefault();

            const {x, y}  = clientXY(e);
            const dx      = x - lastPointerXY.x;
            const dy      = y - lastPointerXY.y;
            lastPointerXY = {x, y};

            const movePx2 = dx*dx + dy*dy;
            if (movePx2 > 16) draggedThisGesture = true;

            const worldYawAxis   = new THREE.Vector3(0, 1, 0);
            const worldRollAxis  = new THREE.Vector3(0, 0, 1);

            const dragSensitivity = isMobile ? 0.006 : 0.005;
            const qHoriz = new THREE.Quaternion().setFromAxisAngle(worldYawAxis,   dx * dragSensitivity);
            const qVert  = new THREE.Quaternion().setFromAxisAngle(worldRollAxis, -dy * dragSensitivity);

            dragQuaternion.premultiply(qHoriz).premultiply(qVert);
            cubeGroup.quaternion.copy(dragQuaternion).multiply(baseQuaternion);
        }

        function onPointerUp(){
            if (!isPointerDragging) return;
            isPointerDragging = false;

            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup',   onPointerUp);

            snapToNearest90();
            if (draggedThisGesture) suppressNextClick = true;
        }

        function createDotsSphere(color) {
            const sphere = new THREE.Group();
            const blackSphere = new THREE.Mesh(sphereGeometry, blackMaterial);
            sphere.add(blackSphere);

            const dotPositions = [
                [0, 1, 0], [0, -1, 0], [1, 0, 0],
                [-1, 0, 0], [0, 0, 1], [0, 0, -1]
            ];

            // Scale dot size proportionally to sphere size
            const dotSize = BOARD_SIZE === 4 ? 0.12 : 0.15;

            dotPositions.forEach(pos => {
                const dotGeometry = new THREE.SphereGeometry(dotSize, 32, 32);
                let dot;
                if (color == "blue") {
                    dot = new THREE.Mesh(dotGeometry, blueDotMaterial);
                }
                else {
                    dot = new THREE.Mesh(dotGeometry, redDotMaterial);
                }

                // Use sphereRadius for dot positioning
                const sphereRadius = 0.7;
                dot.position.set(pos[0] * sphereRadius, pos[1] * sphereRadius, pos[2] * sphereRadius);

                const scale = 1;
                dot.scale.set(scale, scale, 0.01);

                dot.lookAt(0, 0, 0);

                sphere.add(dot);
            });

            return sphere;
        }

        var clickableSpheres = [];
        var gameState = JSON.parse('{{ game_state|safe }}');
        var currentGameState = gameState;
        gameState.forEach((layer, x) => {
            layer.forEach((row, y) => {
                row.forEach((cell, z) => {
                    var sphere;
                    switch (cell) {
                        case 'BLACK':
                            sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                            break;
                        case 'BLUE':
                            sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                            break;
                        case 'RED':
                            sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                            break;
                        default:
                            sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                    }
                    sphere.position.set(-y*2+MAX_COORD, -z*2+MAX_COORD, -x*2+MAX_COORD);
                    sphere.userData = {
                        position: {x: x, y: y, z: z},
                        originalPosition: {x: x, y: y, z: z},
                        clickable: (y == 0)
                    };
                    if (y == 0) {
                        clickableSpheres.push(sphere);
                    }
                    piecesGroup.add(sphere);
                });
            });
        });

        scene.add(cubeGroup);

        // Initialize Raycaster
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        // Camera position - adjusted for board size
        const initialCameraMultiplier = BOARD_SIZE === 4 ? 1.35 : 1.0;
        camera.position.set(7 * initialCameraMultiplier, 4 * initialCameraMultiplier, 3 * initialCameraMultiplier);
        camera.lookAt(scene.position);

        function resizeRenderer() {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }
            return needResize;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            resizeRenderer();
            renderer.render(scene, camera);
        }

        animate();

        //--------------END-----Scene Setup-----END-----------------------------------------

        window.soundsMuted = false;

        window.toggleSoundsMuted = function(muted) {
            window.soundsMuted = muted;
        };

        function playSound(soundType) {
            if (window.soundsMuted) return;
            const sound = document.getElementById(soundType + "Sound");
            if (sound) {
                sound.play();
            }
        }

        function showToast(message) {
            const toast = document.getElementById('invalidMoveToast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const redWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0xe03c11,
            emissive: 0xe03c11,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });
        const blueWinningMaterial = new THREE.MeshPhongMaterial({
            color: 0x116ae0,
            emissive: 0x116ae0,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.3
        });

        const highlightCubeGroup = new THREE.Group();
        cubeGroup.add(highlightCubeGroup);

        function highlightWinningRun(winner, winningRun) {
            if (!winningRun) return;
    
            if (isRotating) {
                setTimeout(() => highlightWinningRun(winner, winningRun), 40);
                return;
            }

            const winningMaterial = winner === 'RED' ? redWinningMaterial : blueWinningMaterial;

            winningRun.forEach(([x, y, z]) => {
                const cube = new THREE.Mesh(cubeGeometry, winningMaterial);
                const piece = piecesGroup.children.find(sphere => 
                    sphere.userData.originalPosition.x === x && 
                    sphere.userData.originalPosition.y === y && 
                    sphere.userData.originalPosition.z === z
                );
                if (piece) {
                    cube.position.copy(piece.position);
                    highlightCubeGroup.add(cube);
                }
            });

            renderer.render(scene, camera);
        }

        function jigglePieces(row, direction, callback) {
            if (isJiggling) return;
            isJiggling = true;

            const JIGGLE_DURATION = 450;
            const JIGGLE_AMPLITUDE = 0.15;

            const startPositions = row.map(piece => piece.position.clone());
            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / JIGGLE_DURATION, 1);

                if (progress < 1) {
                    const displacement = Math.sin(progress * Math.PI * 7) * JIGGLE_AMPLITUDE * (1 - progress);

                    row.forEach((piece, index) => {
                        const start = startPositions[index];
                        switch (direction) {
                            case 'LEFT':
                            case 'RIGHT':
                                piece.position.set(
                                    start.x,
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                                break;
                            case 'FRONT':
                            case 'BACK':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y,
                                    start.z + (index % 2 == 0 ? displacement : -displacement)
                                );
                                break;
                            case 'UP':
                            case 'DOWN':
                                piece.position.set(
                                    start.x + (index % 2 == 0 ? displacement : -displacement),
                                    start.y + (index % 2 == 0 ? displacement : -displacement),
                                    start.z
                                );
                                break;
                        }
                    });

                    requestAnimationFrame(update);
                } else {
                    row.forEach((piece, index) => {
                        piece.position.copy(startPositions[index]);
                    });

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function getRowToJiggle(piece) {
            const { x, y, z } = piece.userData.originalPosition;
            const currentDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            const backDirection = currentDirectionMapping['BACK'];
            const row = [];
            
            piecesGroup.children.forEach(sphere => {
                const spherePos = sphere.userData.originalPosition;
                switch(backDirection) {
                    case 'FRONT':
                    case 'BACK':
                        if (spherePos.x === x && spherePos.z === z) {
                            row.push(sphere);
                        }
                        break;
                    case 'LEFT':
                    case 'RIGHT':
                        if (spherePos.y === y && spherePos.z === z) {
                            row.push(sphere);
                        }
                        break;
                    case 'TOP':
                    case 'BOTTOM':
                        if (spherePos.x === x && spherePos.y === y) {
                            row.push(sphere);
                        }
                        break;
                }
            });
            
            let sortedRow = [...row];
            let coordKey;
            let ascending;
            
            switch(backDirection) {
                case 'FRONT':
                    coordKey = 'y';
                    ascending = false;
                    break;
                case 'BACK':
                    coordKey = 'y';
                    ascending = true;
                    break;
                case 'LEFT':
                    coordKey = 'x';
                    ascending = false;
                    break;
                case 'RIGHT':
                    coordKey = 'x';
                    ascending = true;
                    break;
                case 'TOP':
                    coordKey = 'z';
                    ascending = false;
                    break;
                case 'BOTTOM':
                    coordKey = 'z';
                    ascending = true;
                    break;
            }
            
            sortedRow.sort((a, b) => {
                if (ascending) {
                    return a.userData.originalPosition[coordKey] - b.userData.originalPosition[coordKey];
                } else {
                    return b.userData.originalPosition[coordKey] - a.userData.originalPosition[coordKey];
                }
            });
            
            if (sortedRow.length === BOARD_SIZE) {
                // For visual effect, if there's an empty middle we only jiggle the first pieces
                const middleIndex = Math.floor(BOARD_SIZE / 2);
                const middlePiece = sortedRow[middleIndex];
                const middlePieceType = getPieceType(middlePiece);

                if (middlePieceType === 'EMPTY') {
                    return sortedRow.slice(0, middleIndex);
                }
            }

            return row;
        }

        function logicalDir(dir) {
            switch (dir) {
                case "LEFT":  return "RIGHT";
                case "RIGHT": return "LEFT";
                default:      return dir;
            }
        }


        var lastIntersected = null;

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);

            if (intersects.length > 0) {
                if (lastIntersected !== intersects[0].object) {
                    if (lastIntersected) {
                        lastIntersected.material = lastIntersected.currentMaterial;
                    }
                    lastIntersected = intersects[0].object;
                    lastIntersected.currentMaterial = lastIntersected.material;
                    lastIntersected.material = highlightMaterial;
                }
            } else {
                if (lastIntersected) {
                    lastIntersected.material = lastIntersected.currentMaterial;
                    lastIntersected = null;
                }
            }
        }

        function onMouseOut(event) {
            if (lastIntersected) {
                lastIntersected.material = lastIntersected.currentMaterial;
                lastIntersected = null;
            }
        }

        function onKeyDown(event) {
            let direction;
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    direction = 'DOWN';
                    break;
                case 'ArrowDown':
                case 's':
                    direction = 'UP';
                    break;
                case 'ArrowLeft':
                case 'a':
                    direction = 'RIGHT';
                    break;
                case 'ArrowRight':
                case 'd':
                    direction = 'LEFT';
                    break;
                case 'v':
                    toggleNeutralPiecesVisibility();
                    return;
                default:
                    return;
            }
            handleRotation(direction);
        }

        window.addEventListener('keydown', onKeyDown, false);

        function onMouseClick(event) {
            if (suppressNextClick) { suppressNextClick = false; return; }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object);
                }
            }
        }

        function rotateCube(direction) {
            // Update pieces game board indexed locations in cube
            updatePieceLocations(direction);
            // Update pieces actual locations in space for rendering
            rotatePieces(direction);
        }

        function reapplyRotations() {
            // Starting at the default mapping, rotate until we get to the current mapping (cube rotation). This will rotate the game 
            // state to match the rotation the user currently has set
            const targetDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            let directionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'};
            let count = 0;
            while (!(directionMapping['TOP'] == targetDirectionMapping['TOP'])) {
                if (count % 2 == 0) {
                    if (count % 4 == 0) {
                        rotateCube('LEFT');
                        updateDirectionMapping(directionMapping, 'LEFT');
                    }
                    else {
                        rotateCube('RIGHT');
                        updateDirectionMapping(directionMapping, 'RIGHT');
                    }
                }
                else {
                    rotateCube('UP');
                    updateDirectionMapping(directionMapping, 'UP');
                }
                count += 1;
            }
            while (!(directionMapping['FRONT'] == targetDirectionMapping['FRONT'])) {
                rotateCube('RIGHT');
                updateDirectionMapping(directionMapping, 'RIGHT');
            }
        }

        function updateDirectionMapping(directionMapping, direction) {
            // Update the mapping in place depending on rotation
            frontVal = directionMapping['FRONT']
            switch (direction) {
                case 'UP':
                    directionMapping['FRONT'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['TOP'];
                    directionMapping['TOP'] = frontVal;
                    break;
                case 'DOWN':
                    directionMapping['FRONT'] = directionMapping['TOP'];
                    directionMapping['TOP'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = frontVal;
                    break;
                case 'LEFT':
                    directionMapping['FRONT'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = frontVal;
                    break;
                case 'RIGHT':
                    directionMapping['FRONT'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = frontVal;
                    break;
            }
        }

        function updateClickableSpheres() {
            clickableSpheres = [];
            const currentMapping = JSON.parse(localStorage.getItem('directionMapping'));
            let clickableCoord, clickableValue;

            // Determine which board coordinate should be considered "front"
            switch (currentMapping.FRONT) {
                case 'FRONT':
                    clickableCoord = 'y';
                    clickableValue = 0;
                    break;
                case 'BACK':
                    clickableCoord = 'y';
                    clickableValue = MAX_COORD;
                    break;
                case 'LEFT':
                    clickableCoord = 'x';
                    clickableValue = 0;
                    break;
                case 'RIGHT':
                    clickableCoord = 'x';
                    clickableValue = MAX_COORD;
                    break;
                case 'TOP':
                    clickableCoord = 'z';
                    clickableValue = 0;
                    break;
                case 'BOTTOM':
                    clickableCoord = 'z';
                    clickableValue = MAX_COORD;
                    break;
                default:
                    clickableCoord = 'y';
                    clickableValue = 0;
            }

            updateMobilePanels();

            // Use originalPosition (which is never modified by rotations)
            piecesGroup.children.forEach(sphere => {
                if (sphere.userData.originalPosition[clickableCoord] === clickableValue) {
                    sphere.userData.clickable = true;
                    clickableSpheres.push(sphere);
                } else {
                    sphere.userData.clickable = false;
                }
            });
        }

        function updatePieceLocations(direction) {
            piecesGroup.children.forEach(sphere => {
                var x = sphere.userData.position.x;
                var y = sphere.userData.position.y;
                var z = sphere.userData.position.z;
                switch (direction) {
                    case 'UP':
                        sphere.userData.position = { x: x, y: -z + MAX_COORD, z: y };
                        break;
                    case 'DOWN':
                        sphere.userData.position = { x: x, y: z, z: -y + MAX_COORD };
                        break;
                    case 'LEFT':
                        sphere.userData.position = { x: y, y: -x + MAX_COORD, z: z };
                        break;
                    case 'RIGHT':
                        sphere.userData.position = { x: -y + MAX_COORD, y: x, z: z };
                        break;
                }
            });
            updateClickableSpheres();
        }

        function rotatePieces(direction) {
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            var rotation = new THREE.Matrix4().makeRotationAxis(axis.normalize(), angle);
            piecesGroup.children.forEach(sphere => {
                sphere.position.applyMatrix4(rotation);
            });

            renderer.render(scene, camera);
        }

        let totalRotation = new THREE.Quaternion();

        function animateRotation(direction, callback) {
            const startQuaternion = new THREE.Quaternion().copy(cubeGroup.quaternion);
            const endQuaternion = new THREE.Quaternion();
            const angle = Math.PI / 2;
            let axis;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, -1);
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, -1, 0);
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            endQuaternion.setFromAxisAngle(axis.normalize(), angle);
            endQuaternion.multiply(startQuaternion);

            const startTime = Date.now();

            function update() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / ROTATION_DURATION, 1);

                if (progress < 1) {
                    THREE.Quaternion.slerp(startQuaternion, endQuaternion, cubeGroup.quaternion, progress);
                    requestAnimationFrame(update);
                } else {
                    cubeGroup.quaternion.copy(endQuaternion);
                    totalRotation.multiply(endQuaternion);

                    if (lastIntersected) {
                        const fakeEvent = new MouseEvent('mousemove', {
                            clientX: (mouse.x + 1) * window.innerWidth / 2,
                            clientY: (-mouse.y + 1) * window.innerHeight / 2
                        });
                        onMouseMove(fakeEvent);
                    }

                    if (callback) callback();
                }

                renderer.render(scene, camera);
            }

            update();
        }

        function updateBlockerWidget(gameState) {
            if (!blockerWidget) return;

            let redCount = 0;
            let blueCount = 0;
            let moveCount = 0;

            gameState.forEach(layer => {
                layer.forEach(row => {
                    row.forEach(cell => {
                        if (cell === 'RED_BLOCKER') redCount++;
                        if (cell === 'BLUE_BLOCKER') blueCount++;
                        if (cell === 'RED' || cell === 'BLUE') moveCount++;
                    });
                });
            });

            const redIcons = document.querySelectorAll('#red-blockers .blocker-icon');
            redIcons.forEach((icon, index) => {
                if (index < redCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            const blueIcons = document.querySelectorAll('#blue-blockers .blocker-icon');
            blueIcons.forEach((icon, index) => {
                if (index < blueCount) {
                    icon.classList.add('filled');
                } else {
                    icon.classList.remove('filled');
                }
            });

            // Show the correct blocker piece based on player color
            const redBlocker = document.getElementById('red-blocker');
            const blueBlocker = document.getElementById('blue-blocker');
            const xOverlay = document.getElementById('blockerXOverlay');
            
            redBlocker.style.display = window.playerColor === 'RED' ? 'block' : 'none';
            blueBlocker.style.display = window.playerColor === 'BLUE' ? 'block' : 'none';

            if (window.playerColor === 'RED' && moveCount === 0) {
                xOverlay.classList.add('show');
            } else {
                xOverlay.classList.remove('show');
            }
        }

        function animatePush(piece, startPos, endPos) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const duration = 500;

                function update() {
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    
                    // Cubic easing
                    const easedProgress = progress < 0.5 
                        ? 4 * progress * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    piece.position.lerpVectors(startPos, endPos, easedProgress);

                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        piece.position.copy(endPos);
                        resolve();
                    }

                    renderer.render(scene, camera);
                }

                update();
            });
        }

        function getPieceType(piece) {
            if (piece.material === redMaterial) return 'RED';
            if (piece.material === blueMaterial) return 'BLUE';
            if (piece.material === blackMaterial) return 'BLACK';
            if (piece.children.length > 0) {
                return piece.children[0].children[1].material === redDotMaterial ? 'RED_BLOCKER' : 'BLUE_BLOCKER';
            }
            return 'EMPTY';
        }

        function gameToThreePosition(x, y, z) {
            // Convert game coordinates to Three.js world coordinates
            // For 3x3x3: ranges from -2 to +2, for 4x4x4: ranges from -3 to +3
            return new THREE.Vector3(-y * 2 + MAX_COORD, -z * 2 + MAX_COORD, -x * 2 + MAX_COORD);
        }

        function findPieceAtPosition(pos) {
            return piecesGroup.children.find(sphere => 
                sphere.userData.originalPosition.x === pos.x && 
                sphere.userData.originalPosition.y === pos.y && 
                sphere.userData.originalPosition.z === pos.z
            );
        }

        function getRotatedDirection(direction) {
            const directionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            // Find which face is currently facing which direction
            for (const [currentFace, originalFace] of Object.entries(directionMapping)) {
                if (originalFace === direction) {
                    return currentFace;
                }
            }
            return direction;
        }

        function calculatePushEndPosition(piece, direction) {
            const pos = piece.position.clone();
            const PUSH_DISTANCE = 2;

            // Create base push vector (before any rotations)
            let pushVector = new THREE.Vector3();
            
            // In the base orientation:
            // BACK means -x in Three.js space
            // LEFT means +z in Three.js space
            // UP means +y in Three.js space
            switch(direction) {
                case 'BACK':
                    pushVector.set(-PUSH_DISTANCE, 0, 0);
                    break;
                case 'FRONT':
                    pushVector.set(PUSH_DISTANCE, 0, 0);
                    break;
                case 'LEFT':
                    pushVector.set(0, 0, PUSH_DISTANCE);
                    break;
                case 'RIGHT':
                    pushVector.set(0, 0, -PUSH_DISTANCE);
                    break;
                case 'UP':
                    pushVector.set(0, PUSH_DISTANCE, 0);
                    break;
                case 'DOWN':
                    pushVector.set(0, -PUSH_DISTANCE, 0);
                    break;
            }
            
            pos.add(pushVector);
            
            return pos;
        }

        function getPiecesToPush(origin, direction, count) {
            const pieces = [];
            const firstPiece = findPieceAtPosition(origin);
            if (!firstPiece || count === 0) return pieces;
            
            pieces.push(firstPiece);
            let currentPos = {...origin};

            for (let i = 1; i < count; i++) {
                switch (direction) {
                    case 'BACK': currentPos.y++; break;
                    case 'FRONT': currentPos.y--; break;
                    case 'LEFT': currentPos.x--; break;
                    case 'RIGHT': currentPos.x++; break;
                    case 'UP': currentPos.z--; break;
                    case 'DOWN': currentPos.z++; break;
                }
                
                const nextPiece = findPieceAtPosition(currentPos);
                if (nextPiece) {
                    pieces.push(nextPiece);
                }
            }
            
            return pieces;
        }

        function updateGameState(newGameState, pushInfo = null) {
            return new Promise(resolve => {
                if (isAnimating || isRotating) {
                    requestAnimationFrame(() => {
                        updateGameState(newGameState, pushInfo).then(resolve);
                    });
                    return;
                }
                // Save the current local rotation (clients view)
                const currentRotation = cubeGroup.quaternion.clone();
                
                if (pushInfo && pushInfo.pieces_pushed > 0) {
                    const { origin, direction, pieces_pushed } = pushInfo;
                    const piecesToMove = getPiecesToPush(origin, direction, pieces_pushed);
                    
                    if (piecesToMove.length > 0) {
                        isAnimating = true;
                        const animations = piecesToMove.map(piece => {
                            const startPos = piece.position.clone();
                            const endPos = calculatePushEndPosition(piece, direction);
                            return animatePush(piece, startPos, endPos);
                        });
                        
                        Promise.all(animations).then(() => {
                            isAnimating = false;
                            // Rebuild board from canonical state...
                            updatePiecesFromGameState(newGameState);
                            // ...then restore the saved rotation.
                            cubeGroup.quaternion.copy(currentRotation);
                            updateClickableSpheres();
                            resolve();
                        });
                    } else {
                        updatePiecesFromGameState(newGameState);
                        cubeGroup.quaternion.copy(currentRotation);
                        updateClickableSpheres();
                        resolve();
                    }
                } else {
                    // Even for non-push moves, rebuild and then restore the local rotation.
                    updatePiecesFromGameState(newGameState);
                    cubeGroup.quaternion.copy(currentRotation);
                    updateClickableSpheres();
                    resolve();
                }
            });
        }

        function updatePiecesFromGameState(newGameState) {
            // Update both currentGameState and gameState
            currentGameState = JSON.parse(JSON.stringify(newGameState));
            gameState = newGameState;  // Keep gameState synced for backward compatibility
            
            // Clear existing pieces
            while (piecesGroup.children.length > 0) {
                piecesGroup.remove(piecesGroup.children[0]);
            }

            // Create new pieces in final positions
            gameState.forEach((layer, x) => {
                layer.forEach((row, y) => {
                    row.forEach((cell, z) => {
                        let sphere;
                        switch (cell) {
                            case "BLACK":
                                sphere = new THREE.Mesh(sphereGeometry, blackMaterial);
                                break;
                            case "BLUE":
                                sphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                                break;
                            case "RED":
                                sphere = new THREE.Mesh(sphereGeometry, redMaterial);
                                break;
                            case "BLUE_BLOCKER":
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                const blueDotsSphere = createDotsSphere('blue');
                                sphere.add(blueDotsSphere);
                                break;
                            case "RED_BLOCKER":
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                                const redDotsSphere = createDotsSphere('red');
                                sphere.add(redDotsSphere);
                                break;
                            default:
                                sphere = new THREE.Mesh(sphereGeometry, emptyMaterial);
                        }
                        const threePos = gameToThreePosition(x, y, z);
                        sphere.position.copy(threePos);
                        sphere.userData = {
                            position: { x: x, y: y, z: z },
                            originalPosition: { x: x, y: y, z: z },
                            clickable: (y === 0)
                        };
                        piecesGroup.add(sphere);
                    });
                });
            });

            if (blockerWidget) {
                updateBlockerWidget(gameState);
            }

            highlightMaterial = (playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;
            piecesGroup.children.forEach(sphere => {
                sphere.userData.position = sphere.position.clone();
            });
            updateClickableSpheres();
            renderer.render(scene, camera);
        }

        function sideToDirection(side) {
            switch(side) {
                case 'TOP':
                    return 'UP'
                case 'BOTTOM':
                    return 'DOWN'
                default:
                    return side
            }
        }

        // ON SCREEN CONSOLE
        let onScreenConsole;
        function initOnScreenConsole() {
            onScreenConsole = document.createElement('div');
            onScreenConsole.style.position = 'fixed';
            onScreenConsole.style.bottom = '0';
            onScreenConsole.style.left = '0';
            onScreenConsole.style.right = '0';
            onScreenConsole.style.backgroundColor = 'rgba(0,0,0,0.7)';
            onScreenConsole.style.color = 'white';
            onScreenConsole.style.padding = '10px';
            onScreenConsole.style.fontFamily = 'monospace';
            onScreenConsole.style.fontSize = '12px';
            onScreenConsole.style.maxHeight = '30%';
            onScreenConsole.style.overflowY = 'auto';
            onScreenConsole.style.zIndex = '9999';
            document.body.appendChild(onScreenConsole);

            onScreenConsole.innerHTML = 'On-screen console initialized.<br>';
        }
        console.log = function() {
            const msg = Array.from(arguments).join(' ');
            if (onScreenConsole) {
                onScreenConsole.innerHTML += msg + '<br>';
                onScreenConsole.scrollTop = onScreenConsole.scrollHeight;
            }
        }
        // initOnScreenConsole();
    </script>
    {% block scripts %}{% endblock %}
</body>
</html>

