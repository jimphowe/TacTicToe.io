{% extends 'base_game.html' %}
{% block scripts %}
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<!-- Add React and ReactDOM -->
<script src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
<style>
    .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
    .mobile-undo-button {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
        }
    @media (max-width: 768px) {
        .mobile-undo-button.undo-enabled {
            display: block;
        }
    }
    .mobile-undo-button.disabled {
        opacity: 0.5;
        pointer-events: none;
    }
</style>
{% load static %}
<a href="/" class="btn btn-outline-light home-button">
    <i class="fas fa-home"></i> Home
</a>
<button id="mobile-undo-btn" class="btn btn-outline-light mobile-undo-button {% if undo_enabled %}undo-enabled{% endif %} {% if not can_undo %}disabled{% endif %}" onclick="handleUndo()">
    <i class="fas fa-rotate-left"></i> Undo
</button>
<div id="player-guide-root"></div>
<script>
    const ComputerMoveIndicator = () => {
        return React.createElement('div', {
            style: {
                position: 'fixed',
                top: '96px',
                left: '50%',
                transform: 'translateX(-50%)',
                backgroundColor: 'rgba(30, 41, 59, 0.9)',
                color: 'white',
                padding: '16px 24px',
                borderRadius: '8px',
                boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
                display: 'flex',
                alignItems: 'center',
                gap: '12px',
                transition: 'opacity 300ms',
                zIndex: 1000
            }
        }, [
            React.createElement('div', {
                style: {
                    width: '20px',
                    height: '20px',
                    border: '2px solid white',
                    borderTopColor: 'transparent',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite',
                    minWidth: '20px',
                    minHeight: '20px',
                },
                key: 'spinner'
            }),
            React.createElement('span', {
                style: {
                    fontSize: '14px',
                    fontWeight: '500'
                },
                key: 'text'
            }, 'Computer is thinking...')
        ]);
    };

    // Add the keyframe animation to the document
    const style = document.createElement('style');
    style.textContent = `
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    `;
    document.head.appendChild(style);

    let computerMoveIndicator = null;

    document.addEventListener('DOMContentLoaded', (event) => {
        const root = document.createElement('div');
        root.id = 'computer-move-indicator-root';
        document.body.appendChild(root);

        const defaultDirectionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'};
        localStorage.setItem('directionMapping', JSON.stringify(defaultDirectionMapping));

        const guideRoot = document.getElementById('player-guide-root');
        if (guideRoot) {
            ReactDOM.render(React.createElement(window.PlayerGuide), guideRoot);
        }

        const mobileUndoBtn = document.getElementById('mobile-undo-btn');
        if (mobileUndoBtn) {
            window.addEventListener('undoStateChanged', () => {
                if (window.canUndo) {
                    mobileUndoBtn.classList.remove('disabled');
                } else {
                    mobileUndoBtn.classList.add('disabled');
                }
            });
        }
    });

    let currentReplayData = null;

    function handleGameOver(winner, winningRun, replayData = null) {
        let isTie = !winner
        if (isTie) {
            playSound("move");
        }
        else if (winner == window.playerColor) {
            playSound("win");
        }
        else {
            playSound("lose");
        }
        if (!isTie) {
            highlightWinningRun(winner, winningRun);
        }
        savedWinningRun = winningRun;
        currentReplayData = replayData;
        createGameOverUI(winner, null, null, function() {
            location.reload();
        }, true, replayData);
    }

    let moving = false;

    async function handlePieceClick(piece) {
        if (moving) {
            return;
        }
        moving = true;
        const isBlockerMove = window.isBlockerSelected;

        try {
            const currentDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            const direction = sideToDirection(currentDirectionMapping['BACK']);

            const response = await fetch('/singleplayer/player-move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    position: piece.userData.originalPosition,
                    direction: direction,
                    player: window.playerColor,
                    is_blocker_move: isBlockerMove
                })
            });

            const data = await response.json();

            if (data.status == 'error') {
                console.log(data);
                let row;
                playSound("invalid");
                if (data.message == 'invalid_move') {
                    row = getRowToJiggle(piece);
                    jigglePieces(row, direction, () => {
                        isJiggling = false;
                    });
                }
                else if (data.message == 'insufficient_power') {
                    showToast("Insufficient power")
                    row = getRowToJiggle(piece);
                    jigglePieces(row, direction, () => {
                        isJiggling = false;
                    });
                }
                else if (data.message == 'max_blocker_moves') {
                    showToast("Max blockers placed")
                    window.isBlockerSelected = false;
                    window.dispatchEvent(new Event('blockerStateChanged'));
                }
            } else {
                await updateGameState(data.game_state, data.push_info);
                window.updateControlPanel(data.game_state, data.red_power, data.blue_power);
                playSound("move");
                
                if (data.winner || data.is_tie) {
                    handleGameOver(data.winner, data.winning_run, data.replay_data);
                } else if (isBlockerMove) {
                    window.isBlockerSelected = false;
                    window.dispatchEvent(new Event('blockerStateChanged'));
                } else {
                    const indicatorRoot = document.getElementById('computer-move-indicator-root');
                    ReactDOM.render(React.createElement(ComputerMoveIndicator), indicatorRoot);

                    async function makeBlockerMove() {
                        const blockerResponse = await fetch('/singleplayer/computer-blocker-move', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });

                        const blockerData = await blockerResponse.json();

                        if (blockerData.status === 'success') {
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            await updateGameState(blockerData.game_state);
                            window.updateControlPanel(blockerData.game_state, blockerData.red_power, blockerData.blue_power);
                            playSound("move");

                            if (blockerData.block_again) {
                                await makeBlockerMove();
                            }
                        }

                        return blockerData;
                    }

                    const finalBlockerData = await makeBlockerMove();

                    if (finalBlockerData.winner || finalBlockerData.is_tie) {
                        handleGameOver(finalBlockerData.winner, finalBlockerData.winning_run, finalBlockerData.replay_data);
                    }
                    else {
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        const moveResponse = await fetch('/singleplayer/computer-move', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        });

                        const moveData = await moveResponse.json();

                        ReactDOM.render(null, indicatorRoot);

                        await updateGameState(moveData.game_state, moveData.push_info);
                        window.updateControlPanel(moveData.game_state, moveData.red_power, moveData.blue_power);
                        playSound("move");

                        // Update undo state after complete turn
                        if (moveData.can_undo !== undefined) {
                            window.canUndo = moveData.can_undo;
                            window.dispatchEvent(new Event('undoStateChanged'));
                        }

                        if (moveData.winner || moveData.is_tie) {
                            handleGameOver(moveData.winner, moveData.winning_run, moveData.replay_data);
                        }
                    }
                }
            }
        } catch (error) {
            const indicatorRoot = document.getElementById('computer-move-indicator-root');
            ReactDOM.render(null, indicatorRoot);
            console.log(error);
            showToast("Unexpected Error");
        } finally {
            moving = false;
        }
    }

    async function handleUndo() {
        if (!window.undoEnabled || !window.canUndo || moving) {
            return;
        }
        moving = true;
        try {
            const response = await fetch('/singleplayer/undo', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
            const data = await response.json();
            if (data.status === 'success') {
                // Reset game over state if we're undoing after game ended
                if (window.resetGameOver) {
                    window.resetGameOver();
                }
                await updateGameState(data.game_state);
                window.updateControlPanel(data.game_state, data.red_power, data.blue_power);
                window.canUndo = data.can_undo;
                window.dispatchEvent(new Event('undoStateChanged'));
                playSound("move");
            } else {
                showToast(data.message || "Cannot undo");
            }
        } catch (error) {
            console.log(error);
            showToast("Unexpected Error");
        } finally {
            moving = false;
        }
    }
    window.handleUndo = handleUndo;
</script>
{% endblock %}