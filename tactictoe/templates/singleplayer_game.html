{% extends 'base_game.html' %}
{% block scripts %}
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<style>
    .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
</style>
{% load static %}
<a href="/" class="btn btn-outline-light home-button">
    <i class="fas fa-home"></i> Home
</a>
<script>
    const playerColor = '{{ player_color }}';

    highlightMaterial = (playerColor === 'RED') ? redHighlightMaterial : blueHighlightMaterial;

    function createBlockerSprite() {
        const texture = new THREE.TextureLoader().load("{% static 'images/blocker.png' %}");
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        
        sprite.scale.set(0.7, 0.7, 0.7);
        
        return sprite;
    }

    function addBlockerPiece() {
        blockerPiece = createBlockerSprite();
        blockerPiece.position.set(3, 0, 5);
        scene.add(blockerPiece);
        if (playerColor !== 'BLUE') {
            blockerPiece.visible = false;
        }
    }

    document.addEventListener('DOMContentLoaded', (event) => {
        const defaultDirectionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'};
        localStorage.setItem('directionMapping', JSON.stringify(defaultDirectionMapping));
        addBlockerPiece();
    });

    function handleGameOver(winner, winningRun) {
        if (winner == playerColor) {
            playSound("win");
        }
        else {
            playSound("lose");
        }
        highlightWinningRun(winner, winningRun);
        createGameOverUI(winner, null, function() {
        location.reload();
    });
    }

    let moving = false;

    async function handlePieceClick(piece) {
        if (moving) {
            return;
        }
        moving = true;
        const isBlockerMove = isBlockerSelected;

        try {
            const currentDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
            const direction = sideToDirection(currentDirectionMapping['BACK']);
            const response = await fetch('/singleplayer/player-move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    position: piece.userData.originalPosition,
                    direction: direction,
                    player: playerColor,
                    is_blocker_move: isBlockerMove
                })
            });

            const data = await response.json();

            if (data.status == 'error') {
                playSound("invalid");
                if (data.message == 'invalid_move') {
                    const row = getRowToJiggle(piece);
                    jigglePieces(row, direction, () => {
                        isJiggling = false;
                    });
                }
                else if (data.message == 'last_move_blocker') {
                    showToast("1 blocker per turn");
                    isBlockerSelected = false;
                    blockerPiece.scale.set(0.7, 0.7, 0.7);
                }
                else if (data.message == 'max_blocker_moves') {
                    showToast("Max blockers placed")
                    isBlockerSelected = false;
                    blockerPiece.scale.set(0.7, 0.7, 0.7);
                }
            } else {
                updateGameState(data.game_state);
                playSound("move");

                isBlockerSelected = false;
                blockerPiece.scale.set(0.7, 0.7, 0.7);

                if (data.winner) {
                    handleGameOver(data.winner, data.winning_run);
                } else if (!isBlockerMove) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const response = await fetch('/singleplayer/computer-move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            difficulty: '{{ difficulty|safe }}',
                            player: playerColor
                        })
                    });

                    const data = await response.json();

                    updateGameState(data.game_state);
                    playSound("move");

                    if (data.winner) {
                        handleGameOver(data.winner, data.winning_run);
                    }
                }
            }
        } catch (error) {
            console.error('Error:', error);
            showToast("Unexpected Error");
        } finally {
            moving = false;
        }
    }
</script>
{% endblock %}
