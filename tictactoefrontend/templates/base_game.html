<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tac-Tic-Toe</title>
    {% load static %}
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #homeButton { position: absolute; left: 20px; top: 20px; padding: 10px 20px; font-size: 16px; }
        #restartButton { position: absolute; left: 20px; top: 80px; padding: 10px 20px; font-size: 16px; }
    </style>
    <link rel="icon" href="{% static 'images/favicon.png' %}" type="image/png">
    <script src="{% static 'js/components.js' %}"></script>
</head>
<body>
    <audio id="moveSound" src="{% static 'sounds/move.wav' %}" preload="auto"></audio>
    <!-- Click by complex_waveform -- https://freesound.org/s/213148/ -- License: Attribution 4.0 -->
    <audio id="winSound" src="{% static 'sounds/win.wav' %}" preload="auto"></audio>
    <!-- Good! by syseQ -- https://freesound.org/s/267528/ -- License: Creative Commons 0 -->
    <audio id="loseSound" src="{% static 'sounds/lose.wav' %}" preload="auto"></audio>
    <!-- negative_beeps.wav by themusicalnomad -- https://freesound.org/s/253886/ -- License: Creative Commons 0 -->
    <audio id="startSound" src="{% static 'sounds/start.wav' %}" preload="auto"></audio>
    <!-- Coin_C_09 by cabled_mess -- https://freesound.org/s/350876/ -- License: Creative Commons 0 -->
    <canvas id="myCanvas"></canvas>
    <button id="homeButton" onclick="location.href='/'">Home</button>
    <button id="restartButton" onclick="window.location.reload()">Restart</button>
    <script>
        let isRotating = false;
        let rotationAxis = new THREE.Vector3();
        let rotationAngle = 0;
        let rotationProgress = 0;
        let ROTATION_DURATION = 500;
        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();
        
        function playSound(soundType) {
            const sound = document.getElementById(soundType + "Sound");
            if (sound) {
                sound.play();
            }
        }

        // Scene setup
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas')});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x828282);
        document.body.appendChild(renderer.domElement);

        var highlightMaterial = new THREE.MeshPhongMaterial({
            color: 0xffff00,
            emissive: 0x333300,
            side: THREE.DoubleSide
        });

        // Camera position
        camera.position.set(7, 4, 3);
        camera.lookAt(scene.position);

        var lastIntersected = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);

            if (intersects.length > 0) {
                if (lastIntersected !== intersects[0].object) {
                    if (lastIntersected) {
                        lastIntersected.material = lastIntersected.currentMaterial;
                    }
                    lastIntersected = intersects[0].object;
                    lastIntersected.currentMaterial = lastIntersected.material;
                    lastIntersected.material = highlightMaterial;
                }
            } else {
                if (lastIntersected) {
                    lastIntersected.material = lastIntersected.currentMaterial;
                    lastIntersected = null;
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove, false);

        function onMouseOut(event) {
            if (lastIntersected) {
                lastIntersected.material = lastIntersected.currentMaterial;
                lastIntersected = null;
            }
        }

        window.addEventListener('mouseout', onMouseOut, false);

        function onKeyDown(event) {
            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    rotateCube('UP');
                    break;
                case 'ArrowDown':
                case 's':
                    rotateCube('DOWN');
                    break;
                case 'ArrowLeft':
                case 'a':
                    rotateCube('LEFT');
                    break;
                case 'ArrowRight':
                case 'd':
                    rotateCube('RIGHT');
                    break;
            }
        }

        window.addEventListener('keydown', onKeyDown, false);

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object);
                }
            }
        }

        window.addEventListener('click', onMouseClick, false);

        async function rotateCube(direction) {
            return new Promise((resolve) => {
                if (isRotating) {
                    resolve();
                    return;
                }
            
                isRotating = true;
                rotationProgress = 0;
                
                // Set rotation axis and angle
                switch (direction) {
                    case 'UP':
                        rotationAxis.set(0, 0, 1);
                        rotationAngle = Math.PI / 2;
                        break;
                    case 'DOWN':
                        rotationAxis.set(0, 0, -1);
                        rotationAngle = Math.PI / 2;
                        break;
                    case 'LEFT':
                        rotationAxis.set(0, -1, 0);
                        rotationAngle = Math.PI / 2;
                        break;
                    case 'RIGHT':
                        rotationAxis.set(0, 1, 0);
                        rotationAngle = Math.PI / 2;
                        break;
                }

                updateDirectionMapping(direction);
                
                requestAnimationFrame((timestamp) => animateRotation(timestamp, direction, resolve));
            });
        }

        function updatePieceLocations(direction) {
            clickableSpheres = []
            spheres.forEach(sphere => {
                var x = sphere.userData.position.x;
                var y = sphere.userData.position.y;
                var z = sphere.userData.position.z;
                switch (direction) {
                    case 'UP':
                        sphere.userData.position = { x: x, y: 2 - z, z: y };
                        break;
                    case 'DOWN':
                        sphere.userData.position = { x: x, y: z, z: 2 - y };
                        break;
                    case 'LEFT':
                        sphere.userData.position = { x: y, y: 2 - x, z: z };
                        break;
                    case 'RIGHT':
                        sphere.userData.position = { x: 2 - y, y: x, z: z };
                        break;
                }
                if (sphere.userData.position.y === 0) {
                    clickableSpheres.push(sphere);
                    sphere.userData.clickable = true;
                }
                else {
                    sphere.userData.clickable = false;
                }

                const { x: newX, y: newY, z: newZ } = sphere.userData.position;
                sphere.position.set(-newY * 2 + 2, -newZ * 2 + 2, -newX * 2 + 2);
            });
        }

        function animateRotation(timestamp, direction, resolve) {
            if (!isRotating) {
                resolve();
                return;
            }
    
            if (!animateRotation.startTime) animateRotation.startTime = timestamp;
            const elapsed = timestamp - animateRotation.startTime;
            rotationProgress = Math.min(elapsed / ROTATION_DURATION, 1);
            
            // Apply rotation to the entire cube group
            const rotation = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle * rotationProgress);
            cubeGroup.setRotationFromQuaternion(rotation);
            
            // Re-render the scene
            renderer.render(scene, camera);
            
            if (rotationProgress < 1) {
                requestAnimationFrame(animateRotation);
            } else {
                // Rotation complete
                isRotating = false;
                animateRotation.startTime = null;
                
                // Reset the cube group's rotation
                cubeGroup.rotation.set(0, 0, 0);
                
                console.log(getDirectionFromAxis());
                // Update piece locations in the data structure
                updatePieceLocations(getDirectionFromAxis());
                
                // Update actual positions of spheres
                spheres.forEach(sphere => {
                    const { x, y, z } = sphere.userData.position;
                    sphere.position.set(-y * 2 + 2, -z * 2 + 2, -x * 2 + 2);
                });
                
                // Reset clickable spheres
                updateClickableSpheres();
            }
        }

        function getDirectionFromAxis() {
            console.log(rotationAxis);
            if (rotationAxis.z !== 0) {
                return rotationAxis.z > 0 ? 'UP' : 'DOWN';
            } else if (rotationAxis.y !== 0) {
                return rotationAxis.y > 0 ? 'RIGHT' : 'LEFT';
            }
            return 'NONE';
        }

        function updateClickableSpheres() {
            clickableSpheres = spheres.filter(sphere => sphere.userData.position.y === 0);
            spheres.forEach(sphere => {
                sphere.userData.clickable = (sphere.userData.position.y === 0);
            });
        }

        directionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'}
        function updateDirectionMapping(direction) {
            frontVal = directionMapping['FRONT']
            switch (direction) {
                case 'UP':
                    directionMapping['FRONT'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['TOP'];
                    directionMapping['TOP'] = frontVal;
                    break;
                case 'DOWN':
                    directionMapping['FRONT'] = directionMapping['TOP'];
                    directionMapping['TOP'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['BOTTOM'];
                    directionMapping['BOTTOM'] = frontVal;
                    break;
                case 'LEFT':
                    directionMapping['FRONT'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = frontVal;
                    break;
                case 'RIGHT':
                    directionMapping['FRONT'] = directionMapping['LEFT'];
                    directionMapping['LEFT'] = directionMapping['BACK'];
                    directionMapping['BACK'] = directionMapping['RIGHT'];
                    directionMapping['RIGHT'] = frontVal;
                    break;
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        //MESSSSSSYYYYYY

        function rotatePieces(direction) {
            var angle = Math.PI / 2;

            switch (direction) {
                case 'UP':
                    axis = new THREE.Vector3(0, 0, 1);
                    break;
                case 'DOWN':
                    axis = new THREE.Vector3(0, 0, 1);
                    angle *= -1;
                    break;
                case 'LEFT':
                    axis = new THREE.Vector3(0, 1, 0);
                    angle *= -1;
                    break;
                case 'RIGHT':
                    axis = new THREE.Vector3(0, 1, 0);
                    break;
            }

            var rotation = new THREE.Matrix4().makeRotationAxis(axis.normalize(), angle);

            cubeGroup.children.forEach(child => {
                child.position.applyMatrix4(rotation);
                child.updateMatrix();
            });

            // Re-render the scene
            renderer.render(scene, camera);
        }

        //MESSSSYYYYY ^^

        async function updateGameState(gameState) {
            scene.remove(piecesGroup);
            spheres = [];  // Clear the spheres array
            while (piecesGroup.children.length > 0) {
                piecesGroup.remove(piecesGroup.children[0]);
            }
            clickableSpheres = [];  // Clear clickable spheres array

            // Iterate through the updated game state and create new spheres
            gameState.forEach((layer, x) => {
                layer.forEach((row, y) => {
                    row.forEach((cell, z) => {
                        var material;
                        switch (cell) {
                            case "BLACK":
                                material = blackMaterial;
                                break;
                            case "WHITE":
                                material = whiteMaterial;
                                break;
                            case "RED":
                                material = redMaterial;
                                break;
                            default:
                                material = emptyMaterial; // Handle empty or undefined cells
                        }
                        var sphere = new THREE.Mesh(sphereGeometry, material);
                        sphere.position.set(-y * 2 + 2, -z * 2 + 2, -x * 2 + 2);
                        sphere.userData = {
                            position: { x: x, y: y, z: z },
                            originalPosition: { x: x, y: y, z: z },
                            clickable: (y === 0) // Assuming y=0 makes the sphere clickable
                        };

                        spheres.push(sphere);
                        piecesGroup.add(sphere);

                        if (sphere.userData.clickable) {
                            clickableSpheres.push(sphere);
                        }
                    });
                });
            });

            targetDirectionMapping = directionMapping;
            directionMapping = { 'FRONT': 'FRONT', 'BACK': 'BACK', 'LEFT': 'LEFT', 'RIGHT': 'RIGHT', 'TOP': 'TOP', 'BOTTOM': 'BOTTOM'}
            let count = 0;
            ROTATION_DURATION = 0;
            while (!(directionMapping['TOP'] == targetDirectionMapping['TOP'])) {
                if (count % 2 == 0) {
                    if (count % 4 == 0) {
                        await rotateCube('LEFT');
                    }
                    else {
                        await rotateCube('RIGHT');
                    }
                }
                else {
                    await rotateCube('UP');
                }
                count += 1;
            }
            while (!(directionMapping['FRONT'] == targetDirectionMapping['FRONT'])) {
                console.log('rotating right');
                await rotateCube('RIGHT');
            }
            ROTATION_DURATION = 500;

            spheres.forEach((sphere) => {
                sphere.userData.clickable = (sphere.userData.position.y === 0);
            });

            renderer.render(scene, camera);
        }

        function sideToDirection(side) {
            switch(side) {
                case 'TOP':
                    return 'UP'
                case 'BOTTOM':
                    return 'DOWN'
                default:
                    return side
            }
        }

        // Adding lights
        var ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        var pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-2, -2, -2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        const cubeGroup = new THREE.Group();
        const cubeStructure = new THREE.Group();
        const piecesGroup = new THREE.Group();
        cubeGroup.add(cubeStructure);
        cubeGroup.add(piecesGroup);

        // Set Up Cube
        var tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        var edgePaths = [
            new THREE.Vector3(-3, -3, -3),
            new THREE.Vector3(3, -3, -3),
            new THREE.Vector3(3, 3, -3),
            new THREE.Vector3(-3, 3, -3),
            new THREE.Vector3(-3, -3, 3),
            new THREE.Vector3(3, -3, 3),
            new THREE.Vector3(3, 3, 3),
            new THREE.Vector3(-3, 3, 3),
        ];

        edgePaths.forEach((start, index) => {
            edgePaths.forEach((end, subIndex) => {
                if (start.distanceTo(end) === 6) {
                    var path = new THREE.LineCurve3(start, end);
                    var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
                    var mesh = new THREE.Mesh(geometry, tubeMaterial);
                    cubeStructure.add(mesh);
                }
            });
        });

        function addTube(start, end) {
            var path = new THREE.LineCurve3(new THREE.Vector3(...start), new THREE.Vector3(...end));
            var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
            var mesh = new THREE.Mesh(geometry, tubeMaterial);
            cubeStructure.add(mesh);
        }

        var cubeSize = 6;
        var halfCubeSize = cubeSize / 2;
        var divisionSize = cubeSize / 3;
        for (let offset = -halfCubeSize; offset <= halfCubeSize; offset += divisionSize) {
            for (let z = -halfCubeSize; z <= halfCubeSize; z += divisionSize) {
                addTube([-halfCubeSize, offset, z], [halfCubeSize, offset, z]);
            }
            for (let y = -halfCubeSize; y <= halfCubeSize; y += divisionSize) {
                addTube([offset, y, -halfCubeSize], [offset, y, halfCubeSize]);
            }
            for (let x = -halfCubeSize; x <= halfCubeSize; x += divisionSize) {
                addTube([x, -halfCubeSize, offset], [x, halfCubeSize, offset]);
            }
        }

        // Set Up Balls
        var sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        var redMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
        var whiteMaterial = new THREE.MeshPhongMaterial({color: 0xffffff});
        var blackMaterial = new THREE.MeshPhongMaterial({color: 0x000000});
        var emptyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,  // Can be any color, won't matter as it's invisible
            transparent: true,
            opacity: 0.0,  // Completely transparent
            depthWrite: false  // Avoid rendering issues
        });

        var clickableSpheres = [];
        var spheres = [];
        var gameState = JSON.parse('{{ game_state|safe }}');
        gameState.forEach((layer, x) => {
            layer.forEach((row, y) => {
                row.forEach((cell, z) => {
                    var material;
                    switch (cell) {
                        case 'BLACK':
                            material = blackMaterial;
                            break;
                        case 'WHITE':
                            material = whiteMaterial;
                            break;
                        case 'RED':
                            material = redMaterial;
                            break;
                        default:
                            material = emptyMaterial
                    }
                    var sphere = new THREE.Mesh(sphereGeometry, material);
                    sphere.position.set(-y*2+2, -z*2+2, -x*2+2);
                    sphere.userData = {
                        position: {x: x, y: y, z: z},
                        originalPosition: {x: x, y: y, z: z},
                        clickable: true
                    };
                    if (y == 0) {
                        clickableSpheres.push(sphere);
                    }
                    spheres.push(sphere);
                    piecesGroup.add(sphere); 
                });
            });
        });

        scene.add(cubeGroup);

        // Animation loop
        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (isRotating) {
                animateRotation(timestamp);
            }

            renderer.render(scene, camera);
        }

        // Placeholder functions to be overridden
        function handleGameOver(winner, elo_change) {
            console.error("handleGameOver function not implemented.");
        }

        function handlePieceClick(piece) {
            console.error("handlePieceClick function not implemented.");
        }

        animate();
    </script>
    {% block scripts %}{% endblock %}
</body>
</html>
