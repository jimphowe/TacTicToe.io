<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tac-Tic-Toe</title>
    {% load static %}
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #homeButton { position: absolute; left: 20px; top: 20px; padding: 10px 20px; font-size: 16px; }
    </style>
    <link rel="icon" href="{% static 'images/favicon.png' %}" type="image/png">
</head>
<body>
    <canvas id="myCanvas"></canvas>
    {% url 'home' as home_url %}
    <button id="homeButton" onclick="location.href='{{ home_url }}'">Home</button>
    <script>
        // Scene setup
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas')});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x808080);
        document.body.appendChild(renderer.domElement);

        var highlightMaterial = new THREE.MeshPhongMaterial({
            color: 0xffff00,  // Yellow, or any other color that stands out
            emissive: 0x333300,  // Slightly glowing effect
            side: THREE.DoubleSide  // Ensure the inside of the geometry also gets the material
        });

        var lastIntersected = null;  // Store the last intersected object

        function onMouseMove(event) {
            // Update the mouse variable with coordinates from the event
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(clickableSpheres, true);

            if (intersects.length > 0) {
                if (lastIntersected !== intersects[0].object) {
                    // Reset the last intersected object if it exists
                    if (lastIntersected) {
                        lastIntersected.material = lastIntersected.currentMaterial;
                    }
                    // Store the new intersected object and change its material
                    lastIntersected = intersects[0].object;
                    lastIntersected.currentMaterial = lastIntersected.material;
                    lastIntersected.material = highlightMaterial;
                }
            } else {
                // No intersections, reset the last intersected object if it exists
                if (lastIntersected) {
                    lastIntersected.material = lastIntersected.currentMaterial;
                    lastIntersected = null;
                }
            }
        }

        // Attach the mouse move event listener
        window.addEventListener('mousemove', onMouseMove, false);

        window.addEventListener('mouseout', function() {
            if (lastIntersected) {
                lastIntersected.material = lastIntersected.currentMaterial;
                lastIntersected = null;
            }
        }, false);

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function handlePieceClick(position) {
            console.log('Piece at position', position, 'was clicked');
            // AJAX request to the server with the clicked position
            fetch('/move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')  // Ensure CSRF token is sent with request
                },
                body: JSON.stringify({
                    position: position,
                    player: "RED"
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Move processed:', data);
                // Optionally update the game state here based on server response
            })
            .catch(error => console.error('Error:', error));
        }

        window.addEventListener('click', onMouseClick, false);

        // Adding lights
        var ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        var pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-2, -2, -2);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // Define tube material
        var tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });

        // Define the cube edges with TubeGeometry
        var edgePaths = [
            new THREE.Vector3(-3, -3, -3),
            new THREE.Vector3(3, -3, -3),
            new THREE.Vector3(3, 3, -3),
            new THREE.Vector3(-3, 3, -3),
            new THREE.Vector3(-3, -3, 3),
            new THREE.Vector3(3, -3, 3),
            new THREE.Vector3(3, 3, 3),
            new THREE.Vector3(-3, 3, 3),
        ];

        // Create edges using TubeGeometry
        edgePaths.forEach((start, index) => {
            edgePaths.forEach((end, subIndex) => {
                if (start.distanceTo(end) === 6) { // Check if the points are direct neighbors in a cube
                    var path = new THREE.LineCurve3(start, end);
                    var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
                    var mesh = new THREE.Mesh(geometry, tubeMaterial);
                    scene.add(mesh);
                }
            });
        });

        function addTube(start, end) {
            var path = new THREE.LineCurve3(new THREE.Vector3(...start), new THREE.Vector3(...end));
            var geometry = new THREE.TubeGeometry(path, 64, 0.05, 8, false);
            var mesh = new THREE.Mesh(geometry, tubeMaterial);
            scene.add(mesh);
        }

        var cubeSize = 6;
        var halfCubeSize = 3;
        var divisionSize = cubeSize / 3;
        for (let offset = -halfCubeSize; offset <= halfCubeSize; offset += divisionSize) {
            // Horizontal lines across the cube at each z level
            for (let z = -halfCubeSize; z <= halfCubeSize; z += divisionSize) {
                addTube([-halfCubeSize, offset, z], [halfCubeSize, offset, z]);  // Parallel to x-axis
            }
            // Vertical lines across the cube at each y level
            for (let y = -halfCubeSize; y <= halfCubeSize; y += divisionSize) {
                addTube([offset, y, -halfCubeSize], [offset, y, halfCubeSize]);  // Parallel to z-axis
            }
            // Depth lines through the cube at each x level
            for (let x = -halfCubeSize; x <= halfCubeSize; x += divisionSize) {
                addTube([x, -halfCubeSize, offset], [x, halfCubeSize, offset]);  // Parallel to y-axis
            }
        }

        // Ball setup
        var sphereGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        var redMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
        var whiteMaterial = new THREE.MeshPhongMaterial({color: 0xffffff});
        var blackMaterial = new THREE.MeshPhongMaterial({color: 0x000000});
        var emptyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,  // Can be any color, won't matter as it's invisible
            transparent: true,
            opacity: 0.0,  // Completely transparent
            depthWrite: false  // Avoid rendering issues
        });

        var clickableSpheres = [];
        var gameState = JSON.parse('{{ game_state|safe }}');
        gameState.forEach((layer, x) => {
            layer.forEach((row, z) => {
                row.forEach((cell, y) => {
                    var material;
                    switch (cell) {
                        case 'BLACK':
                            material = blackMaterial;
                            break;
                        case 'WHITE':
                            material = whiteMaterial;
                            break;
                        case 'RED':
                            material = redMaterial;
                            break;
                        default:
                            material = emptyMaterial
                    }
                    var sphere = new THREE.Mesh(sphereGeometry, material);
                    sphere.position.set(-y*2+2, -z*2+2, -x*2+2);
                    if (y == 0) {
                        sphere.userData = {
                            clickable: true,
                            position: {x: x, y: y, z: z}
                        };
                        clickableSpheres.push(sphere);
                    }
                    scene.add(sphere); 
                });
            });
        });

        // Initialize Raycaster
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        // Handle Clicks
        function onMouseClick(event) {
            // Update the mouse variable with coordinates from the event
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(clickableSpheres, true);
            if (intersects.length > 0) {
                // Handle the first intersected object
                var object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    handlePieceClick(object.userData.position);
                }
            }
        }

        // Camera position
        camera.position.set(7, 4, 3);
        camera.lookAt(scene.position);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
