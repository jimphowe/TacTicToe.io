{% extends 'base_game.html' %}
{% block scripts %}
<style>
    .timer {
        position: absolute;
        top: 20px;
        font-size: 24px;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
    }
    #myTimer {
        left: 20px;
    }
    #opponentTimer {
        right: 20px;
    }
</style>
<div id="myTimer" class="timer">Your Time: 3:00</div>
<div id="opponentTimer" class="timer">Your Time: 3:00</div>
<script>
    const myTimerElement = document.getElementById('myTimer');
    const opponentTimerElement = document.getElementById('opponentTimer');

    function stopTimers() {
        clearInterval(myInterval);
        clearInterval(opponentInterval);
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    let myInterval; // Initialize interval for your timer
    let opponentInterval; // Initialize interval for opponent's timer

    let currentTurnId; // Store current player's turn ID
    let myId = {{ request.user.id }};

    let myTimeLeft;
    let opponentTimeLeft; 
    syncGameTimers();
    function syncGameTimers() {
        fetch(`/timer/${'{{ game_id }}'}`)
        .then(response => response.json())
        .then(data => {
            if (myId == data.player_one_id) {
                myTimeLeft = parseInt(data.player_one_time_left);
                opponentTimeLeft = parseInt(data.player_two_time_left);
            }
            else {
                myTimeLeft = parseInt(data.player_two_time_left);
                opponentTimeLeft = parseInt(data.player_one_time_left);
            }

            myTimerElement.textContent = `Your Time: ${formatTime(myTimeLeft)}`;
            opponentTimerElement.textContent = `Opponent's Time: ${formatTime(opponentTimeLeft)}`;

            manageTimers(data.current_turn_id);
        })
        .catch(error => console.error('Failed to fetch timer data:', error));
    }

    function manageTimers(currentTurnId) {
        clearInterval(myInterval);
        clearInterval(opponentInterval);

        // Determine the start time and initialize the timers immediately
        const startTime = Date.now();

        function updateTimer() {
            const now = Date.now();
            const elapsedTime = (now - startTime) / 1000; // Calculate elapsed time in seconds

            // Update the timers based on which player's turn it is
            if (currentTurnId == myId) {
                const newTimeLeft = Math.max(0, myTimeLeft - elapsedTime);
                myTimerElement.textContent = `Your Time: ${formatTime(Math.floor(newTimeLeft))}`;
                if (newTimeLeft <= 0) {
                    clearInterval(myInterval);
                    myTimerElement.textContent = `Your Time: 00:00`;
                }
            } else {
                const newTimeLeft = Math.max(0, opponentTimeLeft - elapsedTime);
                opponentTimerElement.textContent = `Opponent's Time: ${formatTime(Math.floor(newTimeLeft))}`;
                if (newTimeLeft <= 0) {
                    clearInterval(opponentInterval);
                    opponentTimerElement.textContent = `Opponent's Time: 00:00`;
                }
            }
        }

        // Update the timers for the first time without delay
        updateTimer();

        // Set the interval for updating the timer for the current player
        if (currentTurnId == myId) {
            myInterval = setInterval(updateTimer, 1000);
        } else {
            opponentInterval = setInterval(updateTimer, 1000);
        }
    }

    var gameSocket = new WebSocket(
        'ws://' + window.location.host + '/ws/game/' + '{{ game_id }}' + '/'
    );

    gameSocket.onmessage = function(e) {
        var data = JSON.parse(e.data);
        console.log("RECEIVED gameSocket msg with data" + JSON.stringify(data));
        updateGameState(JSON.parse(data.game_state));
        if (data.winner) {
            handleGameOver(data.winner_name, data.elo_change);
        }
        manageTimers(data.turn)
    };

    function handleGameOver(winner, eloChange) {
        if (eloChange > 0) {
            playSound("win");
        }
        else {
            playSound("lose");
        }
        createGameOverUI(winner, eloChange, function() {
            startWebSocket();
            findOpponent().done(function(response) {
                if (response.status === 'success') {
                    playSound("start");
                    window.location.href = '/game/' + response.game_id;
                } else if (response.status === 'waiting') {
                    alert('Waiting for an opponent. You will be notified once matched.');
                }
            }).fail(function() {
                alert('Error finding an opponent. Please try again.');
            });
        });
    }

    function handlePieceClick(piece) {
        fetch('/multiplayer/move', {  // Ensure this URL correctly points to your view handling moves
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')  // Ensuring CSRF token is included for Django
            },
            body: JSON.stringify({
                game_id: '{{ game_id }}',  // Pass the current game ID
                position: piece.userData.originalPosition,
                direction: sideToDirection(directionMapping['BACK'])
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log("Recieved click with data: ");
            console.log(data);
            playSound("move");
            updateGameState(JSON.parse(data.game_state));
            syncGameTimers();
        })
        .catch(error => console.error('Error:', error));
    }

</script>
{% endblock %}
