{% extends 'base_game.html' %}
{% block scripts %}
<style>
    .timer {
        position: absolute;
        top: 20px;
        font-size: 24px;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
    }
    #myTimer {
        left: 20px;
    }
    #opponentTimer {
        right: 20px;
    }
    #resignButton {
        position: absolute;
        bottom: 20px;
        left: 20px;
        padding: 10px 20px;
        font-size: 16px;
        color: white;
        background-color: red; /* Red background for the resign button */
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    #resignButton:hover {
        background-color: darkred; /* Darker red on hover for better interaction feedback */
    }
</style>
<div id="myTimer" class="timer">Your Time: 3:00</div>
<div id="opponentTimer" class="timer">Your Time: 3:00</div>
<button id="resignButton" onclick="handleResignation()">Resign</button>
<script>
    document.addEventListener('DOMContentLoaded', (event) => {
        reapplyRotations();
    });

    const myTimerElement = document.getElementById('myTimer');
    const opponentTimerElement = document.getElementById('opponentTimer');

    function stopTimers() {
        clearInterval(myInterval);
        clearInterval(opponentInterval);
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    let myInterval;
    let opponentInterval;

    let currentTurnId;
    let myId = {{ request.user.id }};

    let myTimeLeft;
    let opponentTimeLeft; 
    syncGameTimers();
    function syncGameTimers() {
        fetch(`/timer/${'{{ game_id }}'}`)
        .then(response => response.json())
        .then(data => {
            if (myId == data.player_one_id) {
                myTimeLeft = parseInt(data.player_one_time_left);
                opponentTimeLeft = parseInt(data.player_two_time_left);
            }
            else {
                myTimeLeft = parseInt(data.player_two_time_left);
                opponentTimeLeft = parseInt(data.player_one_time_left);
            }

            myTimerElement.textContent = `Your Time: ${formatTime(myTimeLeft)}`;
            opponentTimerElement.textContent = `Opponent's Time: ${formatTime(opponentTimeLeft)}`;

            manageTimers(data.current_turn_id);
        })
        .catch(error => console.error('Failed to fetch timer data:', error));
    }

    function manageTimers(currentTurnId) {
        clearInterval(myInterval);
        clearInterval(opponentInterval);

        const startTime = Date.now();

        function updateTimer() {
            const now = Date.now();
            const elapsedTime = (now - startTime) / 1000;

            if (currentTurnId == myId) {
                const newTimeLeft = Math.max(0, myTimeLeft - elapsedTime);
                myTimerElement.textContent = `Your Time: ${formatTime(Math.floor(newTimeLeft))}`;
                if (newTimeLeft <= 0) {
                    clearInterval(myInterval);
                    myTimeLeft = 0;
                    myTimerElement.textContent = `Your Time: 00:00`;
                }
            } else {
                const newTimeLeft = Math.max(0, opponentTimeLeft - elapsedTime);
                opponentTimerElement.textContent = `Opponent's Time: ${formatTime(Math.floor(newTimeLeft))}`;
                if (newTimeLeft <= 0) {
                    clearInterval(opponentInterval);
                    opponentTimeLeft = 0;
                    opponentTimerElement.textContent = `Opponent's Time: 00:00`;
                }
            }
        }

        updateTimer();

        if (currentTurnId == myId) {
            myInterval = setInterval(updateTimer, 1000);
        } else {
            opponentInterval = setInterval(updateTimer, 1000);
        }
    }

    var gameSocket = new WebSocket(
        'ws://' + window.location.host + '/ws/game/' + '{{ game_id }}' + '/'
    );

    gameSocket.onmessage = function(e) {
        var data = JSON.parse(e.data);
        console.log("RECEIVED gameSocket msg with data" + JSON.stringify(data));
        updateGameState(JSON.parse(data.game_state));
        if (data.winner) {
            handleGameOver(data.winner_name, data.elo_change);
        } else {
            syncGameTimers();
        }
    };

    function handleGameOver(winner_name, eloChange) {
        stopTimers();
        if (eloChange > 0) {
            playSound("win");
        }
        else {
            playSound("lose");
        }
        createGameOverUI(winner_name, eloChange, function() {
            startWebSocket();
            findOpponent().done(function(response) {
                if (response.status === 'success') {
                    playSound("start");
                    window.location.href = '/game/' + response.game_id;
                } else if (response.status === 'waiting') {
                    alert('Waiting for an opponent. You will be notified once matched.');
                }
            }).fail(function() {
                alert('Error finding an opponent. Please try again.');
            });
        });
    }

    function handlePieceClick(piece) {
        currentDirectionMapping = JSON.parse(localStorage.getItem('directionMapping'));
        fetch('/multiplayer/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                game_id: '{{ game_id }}',
                position: piece.userData.originalPosition,
                direction: sideToDirection(currentDirectionMapping['BACK'])
            })
        })
        .then(response => response.json())
        .then(data => {
            playSound("move");
            updateGameState(JSON.parse(data.game_state));
            syncGameTimers();
        })
        .catch(error => console.error('Error:', error));
    }

    function handleResignation() {
        fetch('/multiplayer/resign', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                game_id: '{{ game_id }}'
            })
        })
    }

</script>
{% endblock %}
